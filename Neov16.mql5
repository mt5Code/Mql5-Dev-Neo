//+------------------------------------------------------------------+
//| SessionLinesEA.mq5 |
//| Copyright 2025, Your Name |
//| |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Your Name"
#property link ""
#property version "1.98"
#include <Trade\Trade.mqh>
// Stop-loss mode enumeration
enum ENUM_STOPLOSS_MODE
{
   CandleMidSL, // SL at middle candle of FVG
   GapBoundarySL, // SL at FVG boundary
   SwingPointSL, // SL at first swing point
   middleOfVFGSL, // SL at middle of FVG gap
   extremeOfRaid // SL at extreme of raid
};
// Color scheme enumeration
enum COLOR_SCHEME
{
   BlackWhite, // Black and White
   RedGreen // Red and Green
};
// Entry type enumeration
enum ENTRY_TYPE
{
   twoFVGs, // Entry after two FVGs
   FirstFVGandTap, // Entry on first FVG and tap
   firstCloseBeyondCandle // Entry on first close beyond candle after raid
};
// New trading times enumeration
enum TradingMode
{
   EntireDay = 0, // Trade from NYOpen to before CloseAll
   OnlyKillzones = 1 // Trade only within London or NY kill zones
};
// New bias type enumeration (added)
enum BiasTypeEnum
{
   DailyBias, // Current candle-based model
   EMABias // New EMA-based model
};
// Take Profit type enumeration
enum ENUM_TPTYPE
{
   OppositeLQ, // TP at closest opposite level (!raided)
   closestOppLQvsTPMultiple, // TP at closest of opposite or TP multiple
   TPMultiple // TP at user-defined multiple of SL distance
};
// Trade rules enumeration (new)
enum ENUM_TRADERULES
{
   onlyOneTrade, // Only one trade open at a time
   bothLongAndShort // Allow one long and one short simultaneously
};
// Trading style enumeration (new)
enum TRADING_STYLE
{
   OnlyReversals, // Only Reversal Style
   OnlyBreakouts, // Only Breakout Style
   BothReversalsAndBreakouts // Both Styles (Independent)
};
// Breakout entry type enumeration (new)
enum ENTRY_TYPE_BREAKOUT
{
   closeAboveRaidExtreme // Entry on close above/below raid extreme
};
// Input parameters
input TRADING_STYLE TradingStyle = OnlyReversals; // Trading Style
input ENUM_TPTYPE TPTypeReversals = TPMultiple; // Take Profit type for reversals
input double ReversalTPMultiple = 3.0; // Reversal TP Multiple
input ENUM_TRADERULES TradeRules = onlyOneTrade; // Trade Rules (new)
input ENUM_STOPLOSS_MODE SLModeReversals = SwingPointSL; // SL mode for reversals
input ENUM_STOPLOSS_MODE SLModeBreakouts = SwingPointSL; // SL mode for Breakouts
input ENUM_TPTYPE TPTypeBreakouts = TPMultiple; // Take profit type for breakouts
input double BreakoutTPMultiple = 3.0; // Breakout TP Multiple
input int TimeAdjustment = -1; // Time Adjustment (hours)
input int CloseAllHour = 22; // CloseAll Line Hour
input int CloseAllMinutes = 45; // CloseAll Line Minutes
input bool AllowEAToTrade = true; // Allow EA to Trade
input bool AllowLongTrades = true; // Allow Long Trades
input bool AllowShortTrades = true; // Allow Short Trades
input bool UseBiasFilter = true; // Use Bias Filter for Trades
input bool TradeOnNeutralDays = true; // Trade on Neutral Bias Days
input int maxTradesPerRaidLevel = 2; // Max Trades per Raid Level
input double RiskPercentage = 0.20; // Risk Percentage per Trade (0.2%)
input bool UseBE = false; // Use Break-Even Logic
input int NumberOfRForBE = 2; // Number of R for BE
input COLOR_SCHEME colorOfDailyDrawnCandles = BlackWhite; // Color of Daily Drawn Candles
input bool treatIBAsNeutral = true; // Treat Inside Bars as Neutral
input ENTRY_TYPE EntryTypeReversals = twoFVGs; // Entry Type for Reversals (renamed)
input ENTRY_TYPE_BREAKOUT EntryTypeBreakouts = closeAboveRaidExtreme; // Entry Type for Breakouts (new)
input TradingMode TradingTimes = EntireDay; // Trading time restriction
input bool RaidMustBeInKillzone = false; // Require raids within kill zones for entries
input BiasTypeEnum BiasType = DailyBias; // Bias Type (added)
input int EMAValue = 21; // EMA Period for EMABias (added)
// Global variables for reversal trade and level management
bool AsiaLowRaided = false;
bool LondonLowRaided = false;
bool DailyLowRaided = false;
bool AsiaHighRaided = false;
bool LondonHighRaided = false;
bool DailyHighRaided = false;
int AsiaLowTrades = 0;
int LondonLowTrades = 0;
int DailyLowTrades = 0;
int AsiaHighTrades = 0;
int LondonHighTrades = 0;
int DailyHighTrades = 0;
double ActiveLowLevel = DBL_MAX; // Lowest raided low (DBL_MAX if none)
string ActiveLowLevelName = "";
double ActiveHighLevel = DBL_MIN; // Highest raided high (DBL_MIN if none)
string ActiveHighLevelName = "";
double AsiaLow = 0, LondonLow = 0, DailyLow = 0; // Store low levels
double AsiaHigh = 0, LondonHigh = 0, DailyHigh = 0; // Store high levels
datetime AsiaLowValidUntil = 0, LondonLowValidUntil = 0, DailyLowValidUntil = 0; // Track low line validity
datetime AsiaHighValidUntil = 0, LondonHighValidUntil = 0, DailyHighValidUntil = 0; // Track high line validity
datetime AsiaLowRaidTime = 0, LondonLowRaidTime = 0, DailyLowRaidTime = 0; // Track low raid times
datetime AsiaHighRaidTime = 0, LondonHighRaidTime = 0, DailyHighRaidTime = 0; // Track high raid times
bool ProfitableCloseToday = false; // Track if a trade closed with profit today
bool ProfitableCloseLondon = false; // Track profitable close in London KZ (added)
bool ProfitableCloseNY = false; // Track profitable close in NY KZ (added)
bool LondonLevelsSet = false; // New: Flag for TP update after London
bool LondonLevelsUpdated = false; // New: One-time TP update flag
// Variables for firstCloseBeyondCandle (reversal)
bool AsiaLowWaitingForEntry = false;
datetime AsiaLowCurrentRaidTime = 0;
bool LondonLowWaitingForEntry = false;
datetime LondonLowCurrentRaidTime = 0;
bool DailyLowWaitingForEntry = false;
datetime DailyLowCurrentRaidTime = 0;
bool AsiaHighWaitingForEntry = false;
datetime AsiaHighCurrentRaidTime = 0;
bool LondonHighWaitingForEntry = false;
datetime LondonHighCurrentRaidTime = 0;
bool DailyHighWaitingForEntry = false;
datetime DailyHighCurrentRaidTime = 0;
// Global variables for breakout trade and level management
bool BreakoutAsiaLowRaided = false;
bool BreakoutLondonLowRaided = false;
bool BreakoutDailyLowRaided = false;
bool BreakoutAsiaHighRaided = false;
bool BreakoutLondonHighRaided = false;
bool BreakoutDailyHighRaided = false;
int BreakoutAsiaLowTrades = 0;
int BreakoutLondonLowTrades = 0;
int BreakoutDailyLowTrades = 0;
int BreakoutAsiaHighTrades = 0;
int BreakoutLondonHighTrades = 0;
int BreakoutDailyHighTrades = 0;
double BreakoutActiveLowLevel = DBL_MAX;
double BreakoutActiveHighLevel = DBL_MIN;
datetime BreakoutAsiaLowValidUntil = 0, BreakoutLondonLowValidUntil = 0, BreakoutDailyLowValidUntil = 0;
datetime BreakoutAsiaHighValidUntil = 0, BreakoutLondonHighValidUntil = 0, BreakoutDailyHighValidUntil = 0;
datetime BreakoutAsiaLowRaidTime = 0, BreakoutLondonLowRaidTime = 0, BreakoutDailyLowRaidTime = 0;
datetime BreakoutAsiaHighRaidTime = 0, BreakoutLondonHighRaidTime = 0, BreakoutDailyHighRaidTime = 0;
// Breakout setup-specific
string CurrentBreakoutLowLevelName = "";
datetime CurrentBreakoutLowRaidTime = 0;
double CurrentBreakoutLowKeyLevel = 0;
datetime CurrentBreakoutLowKeyTime = 0;
bool BreakoutLowHasKey = false;
bool BreakoutLowWaitingForRetrace = false;
string CurrentBreakoutHighLevelName = "";
datetime CurrentBreakoutHighRaidTime = 0;
double CurrentBreakoutHighKeyLevel = 0;
datetime CurrentBreakoutHighKeyTime = 0;
bool BreakoutHighHasKey = false;
bool BreakoutHighWaitingForRetrace = false;
ulong CurrentBreakoutShortTicket = 0;
double CurrentBreakoutShortSL = 0;
ulong CurrentBreakoutLongTicket = 0;
double CurrentBreakoutLongSL = 0;
// Timestamps for when breakout keys are set (to prevent same-bar entry)
datetime CurrentBreakoutLowKeySetTime = 0;
datetime CurrentBreakoutHighKeySetTime = 0;
// Killzone raid flags for breakouts
bool BreakoutRaidedLowInLondon = false;
bool BreakoutRaidedLowInNY = false;
bool BreakoutRaidedHighInLondon = false;
bool BreakoutRaidedHighInNY = false;
CTrade trade; // Trade object for managing positions
int FVGBullishCount = 0; // Count of bullish FVGs (reversal)
double FirstFVGGapLow = 0; // Low of the first bullish FVG gap
datetime LastBullishFVGTime = 0; // Time of the last bullish FVG detected
int FVGBearishCount = 0; // Count of bearish FVGs (reversal)
double FirstFVGGapHigh = 0; // High of the first bearish FVG gap
datetime LastBearishFVGTime = 0; // Time of the last bearish FVG detected
datetime BiasCandle1Time = 0, BiasCandle2Time = 0; // Times for drawn bias candles
double BiasCandle1Open = 0, BiasCandle1Close = 0, BiasCandle1High = 0, BiasCandle1Low = 0;
double BiasCandle2Open = 0, BiasCandle2Close = 0, BiasCandle2High = 0, BiasCandle2Low = 0;
// Variables for FirstFVGandTap (reversal)
double LatestBullishFVGLower = 0;
double LatestBullishFVGUpper = 0;
double LatestBullishFVGSL = 0;
string LatestBullishLevelName = "";
bool HasLeftBullish = false;
double LatestBearishFVGLower = 0;
double LatestBearishFVGUpper = 0;
double LatestBearishFVGSL = 0;
string LatestBearishLevelName = "";
bool HasLeftBearish = false;
// New variables for updated twoFVGs logic (reversal)
bool HasTappedFirstBullishFVG = false;
double TappedFirstBullishGapLow = 0;
double LatestUntappedBullishGapLow = 0;
double LatestUntappedBullishGapHigh = 0;
bool HasTappedFirstBearishFVG = false;
double TappedFirstBearishGapHigh = 0;
double LatestUntappedBearishGapLow = 0;
double LatestUntappedBearishGapHigh = 0;
// New variables for kill zone raid tracking (reversal)
bool raidedLowInLondon = false;
bool raidedLowInNY = false;
bool raidedHighInLondon = false;
bool raidedHighInNY = false;
datetime lastLondonStart = 0;
datetime lastNYStart = 0;
datetime lastDay = 0;
datetime last_daily_time = 0; // New: For robust daily reset
int ema_handle = INVALID_HANDLE; // Handle for EMA (added)
datetime LastTradeDay = 0;
//+------------------------------------------------------------------+
//| Get extreme value (low/high) in raid range using bar shifts |
//| Fixed: Use exact=true for precise open-time match. |
//+------------------------------------------------------------------+
double GetExtremeOfRaid(bool is_long, datetime raid_time, datetime &extreme_time_out)
{
   datetime current_time = TimeCurrent();
   datetime day_start = current_time - (current_time % 86400); // Clip to today
   int end_shift = 1; // Always the previous closed bar at entry time (robust)
   int raid_shift = iBarShift(_Symbol, PERIOD_CURRENT, raid_time, true); // Exact match for raid bar open time
   if(raid_time < day_start) raid_time = day_start; // Prevent prior days
   raid_shift = iBarShift(_Symbol, PERIOD_CURRENT, raid_time, true); // Re-fetch clipped
   if(raid_shift == -1 || raid_shift < end_shift)
   {
      // Fallback: raid bar not found or after end (impossible, use end bar)
      extreme_time_out = iTime(_Symbol, PERIOD_CURRENT, end_shift);
      return is_long ? iLow(_Symbol, PERIOD_CURRENT, end_shift) : iHigh(_Symbol, PERIOD_CURRENT, end_shift);
   }
   double extreme = is_long ? DBL_MAX : DBL_MIN;
   int extreme_shift = -1;
   // Loop from end_shift (newer, shift 1) to raid_shift (older, inclusive)
   for(int shift = end_shift; shift <= raid_shift; shift++)
   {
      double val = is_long ? iLow(_Symbol, PERIOD_CURRENT, shift) : iHigh(_Symbol, PERIOD_CURRENT, shift);
      if((is_long && val < extreme) || (!is_long && val > extreme))
      {
         extreme = val;
         extreme_shift = shift;
      }
   }
   if(extreme_shift != -1)
   {
      extreme_time_out = iTime(_Symbol, PERIOD_CURRENT, extreme_shift);
   }
   else
   {
      // Fallback if no valid shifts (rare)
      extreme_time_out = iTime(_Symbol, PERIOD_CURRENT, end_shift);
      extreme = is_long ? iLow(_Symbol, PERIOD_CURRENT, end_shift) : iHigh(_Symbol, PERIOD_CURRENT, end_shift);
   }
   return extreme;
}
//+------------------------------------------------------------------+
//| Determine bias (renamed and modified for BiasType) |
//+------------------------------------------------------------------+
string DetermineBias()
{
   if(!UseBiasFilter) return "AllowAll"; // New: Bypass bias if disabled
   MqlRates rates[];
   int copied = CopyRates(_Symbol, PERIOD_D1, 1, 2, rates);
   if(copied < 2) return "Neutral";
   double candle1_open = rates[0].open; // Candle 1 (older, second to last)
   double candle1_close = rates[0].close;
   double candle1_high = rates[0].high;
   double candle1_low = rates[0].low;
   double candle2_open = rates[1].open; // Candle 2 (newer, latest closed)
   double candle2_close = rates[1].close;
   double candle2_high = rates[1].high;
   double candle2_low = rates[1].low;
   // Store for drawing and bias calculation
   BiasCandle1Open = candle1_open; // Older candle
   BiasCandle1Close = candle1_close;
   BiasCandle1High = candle1_high;
   BiasCandle1Low = candle1_low;
   BiasCandle2Open = candle2_open; // Newer candle
   BiasCandle2Close = candle2_close;
   BiasCandle2High = candle2_high;
   BiasCandle2Low = candle2_low;
   BiasCandle1Time = rates[0].time;
   BiasCandle2Time = rates[1].time;
   Print("BiasCandle1 (older, left): Time=", TimeToString(BiasCandle1Time), " Open=", BiasCandle1Open, " Close=", BiasCandle1Close, " High=", BiasCandle1High, " Low=", BiasCandle1Low);
   Print("BiasCandle2 (newer, right): Time=", TimeToString(BiasCandle2Time), " Open=", BiasCandle2Open, " Close=", BiasCandle2Close, " High=", BiasCandle2High, " Low=", BiasCandle2Low);
   if(BiasType == EMABias)
   {
      double ema_buf[2];
      if(ema_handle == INVALID_HANDLE || CopyBuffer(ema_handle, 0, 1, 2, ema_buf) < 2) return "Neutral";
      double last_close = rates[1].close;
      double prev_close = rates[0].close;
      double last_ema = ema_buf[1]; // Fixed: ema_buf[1] is for shift 1 (yesterday, last)
      double prev_ema = ema_buf[0]; // Fixed: ema_buf[0] is for shift 2 (day before, prev)
      if(last_close == last_ema) // Added explicit check for equality
      {
         Print("Bias: Neutral (EMA - exact equality)");
         return "Neutral";
      }
      if(last_close > last_ema)
      {
         Print("Bias: Bullish (EMA)");
         return "Bullish";
      }
      else if(last_close < last_ema && prev_close < prev_ema)
      {
         Print("Bias: Bearish (EMA)");
         return "Bearish";
      }
      else
      {
         Print("Bias: Neutral (EMA)");
         return "Neutral";
      }
   }
   else // DailyBias
   {
      // Displacement logic using correct candle order
      if(candle2_close > candle1_high && candle2_low >= candle1_low)
      {
         Print("Bias: Bullish");
         return "Bullish";
      }
      else if(candle2_close < candle1_low && candle2_high <= candle1_high)
      {
         Print("Bias: Bearish");
         return "Bearish";
      }
      // Reversal logic
      if(candle2_high > candle1_high && candle2_close < candle1_high && candle2_low >= candle1_low)
      {
         Print("Bias: Bearish");
         return "Bearish";
      }
      else if(candle2_low < candle1_low && candle2_close > candle1_low && candle2_high <= candle1_high)
      {
         Print("Bias: Bullish");
         return "Bullish";
      }
      // Directional outside bars
      if(candle2_high > candle1_high && candle2_low < candle1_low && candle2_close > candle1_high)
      {
         Print("Bias: Bullish (Directional Outside)");
         return "Bullish";
      }
      else if(candle2_high > candle1_high && candle2_low < candle1_low && candle2_close < candle1_low)
      {
         Print("Bias: Bearish (Directional Outside)");
         return "Bearish";
      }
      // Outside day logic
      if(candle2_high > candle1_high && candle2_low < candle1_low && candle2_open >= candle1_low && candle2_open <= candle1_high && candle2_close >= candle1_low && candle2_close <= candle1_high)
      {
         MqlRates lower_rates[];
         datetime start_time = rates[1].time;
         datetime end_time = start_time + 86400;
         int copied_lower = CopyRates(_Symbol, PERIOD_CURRENT, start_time, end_time, lower_rates);
         if(copied_lower > 0)
         {
            datetime first_high_break = 0;
            datetime first_low_break = 0;
            for(int i = 0; i < copied_lower; i++)
            {
               if(lower_rates[i].high > candle1_high && first_high_break == 0) first_high_break = lower_rates[i].time;
               if(lower_rates[i].low < candle1_low && first_low_break == 0) first_low_break = lower_rates[i].time;
               if(first_high_break > 0 && first_low_break > 0) break;
            }
            if(first_high_break > 0 && first_low_break > 0)
            {
               if(first_high_break < first_low_break)
               {
                  Print("Bias: Bullish (Outside Day)");
                  return "Bullish";
               }
               else
               {
                  Print("Bias: Bearish (Outside Day)");
                  return "Bearish";
               }
            }
         }
      }
      // Inside day logic
      else if(candle2_high <= candle1_high && candle2_low >= candle1_low)
      {
         if(treatIBAsNeutral)
         {
            Print("Bias: Neutral (Inside Day)");
            return "Neutral";
         }
         else
         {
            if(candle1_close > candle1_open)
            {
               Print("Bias: Bullish (Inside Day)");
               return "Bullish";
            }
            else if(candle1_close < candle1_open)
            {
               Print("Bias: Bearish (Inside Day)");
               return "Bearish";
            }
            else
            {
               Print("Bias: Neutral (Inside Day)");
               return "Neutral";
            }
         }
      }
      Print("Bias: Neutral");
      return "Neutral";
   }
}
//+------------------------------------------------------------------+
//| Calculate lot size based on risk percentage |
//+------------------------------------------------------------------+
double CalculateLotSize(double entry_price, double sl_price)
{
   double sl_distance = MathAbs(entry_price - sl_price);
   if(sl_distance <= 0) return 0;
   double account_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tick_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double risk_amount = account_balance * RiskPercentage / 100.0;
   double lot_size = risk_amount / (sl_distance / tick_size * tick_value);
   double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   lot_size = MathRound(lot_size / lot_step) * lot_step;
   lot_size = MathMax(min_lot, MathMin(max_lot, lot_size));
   return lot_size;
}
//+------------------------------------------------------------------+
//| Check if can open new trade based on TradeRules (new) for reversals |
//+------------------------------------------------------------------+
bool CanOpenNewTrade(bool is_long)
{
   if(TradeRules == onlyOneTrade) return !HasOpenPosition();
   // bothLongAndShort: Check no same-direction open
   ENUM_POSITION_TYPE target_type = is_long ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
   int total = PositionsTotal();
   for(int i = 0; i < total; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         if((ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE) == target_type) return false;
      }
   }
   return true;
}
//+------------------------------------------------------------------+
//| Check if can open new breakout trade (independent) |
//+------------------------------------------------------------------+
bool CanOpenNewBreakoutTrade(bool is_long)
{
   if(TradeRules == onlyOneTrade)
   {
      int total = PositionsTotal();
      for(int i = 0; i < total; i++)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            string comment = PositionGetString(POSITION_COMMENT);
            if(StringFind(comment, "Breakout") >= 0) return false;
         }
      }
      return true;
   }
   // bothLongAndShort: Check no same-direction breakout open
   ENUM_POSITION_TYPE target_type = is_long ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;
   int total = PositionsTotal();
   for(int i = 0; i < total; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         string comment = PositionGetString(POSITION_COMMENT);
         if(StringFind(comment, "Breakout") >= 0 && (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE) == target_type) return false;
      }
   }
   return true;
}
//+------------------------------------------------------------------+
//| Check for open positions (reversal) |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   int total = PositionsTotal();
   for(int i = 0; i < total; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         string comment = PositionGetString(POSITION_COMMENT);
         if(StringFind(comment, "Raid") >= 0 || StringFind(comment, "FVG") >= 0) return true; // Reversal comments
      }
   }
   return false;
}
//+------------------------------------------------------------------+
//| Close all open trades for the current symbol |
//+------------------------------------------------------------------+
void CloseAllTrades()
{
   int total = PositionsTotal();
   for(int i = total - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         trade.PositionClose(ticket);
      }
   }
}
//+------------------------------------------------------------------+
//| Check if there was a profitable close in the entire day (updated to check ANY large win) |
//+------------------------------------------------------------------+
bool CheckProfitableCloseToday()
{
   datetime current_time = TimeCurrent();
   string current_date = TimeToString(current_time, TIME_DATE);
   datetime start_time = StringToTime(current_date + " 00:00:00");
   datetime end_time = current_time;
   if(!HistorySelect(start_time, end_time)) return false;
   double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercentage / 100.0;
   double profit_threshold = risk_amount / 4.0;
   int total_deals = HistoryDealsTotal();
   for(int i = 0; i < total_deals; i++)
   {
      ulong deal_ticket = HistoryDealGetTicket(i);
      if(deal_ticket == 0) continue;
      string deal_symbol = HistoryDealGetString(deal_ticket, DEAL_SYMBOL);
      long deal_entry = HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);
      datetime deal_time = (datetime)HistoryDealGetInteger(deal_ticket, DEAL_TIME);
      if(deal_symbol == _Symbol && deal_entry == DEAL_ENTRY_OUT && deal_time > start_time && deal_time <= end_time)
      {
         double deal_profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
         if(deal_profit > profit_threshold) return true;
      }
   }
   return false;
}
//+------------------------------------------------------------------+
//| Check if there was a profitable close in a specific killzone (updated to check ANY large win in zone) |
//+------------------------------------------------------------------+
bool CheckProfitableCloseInKillzone(string zone)
{
   datetime current_time = TimeCurrent();
   string current_date = TimeToString(current_time, TIME_DATE);
   datetime start_time = StringToTime(current_date + " 00:00:00");
   datetime end_time = current_time;
   if(!HistorySelect(start_time, end_time)) return false;
   double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercentage / 100.0;
   double profit_threshold = risk_amount / 4.0;
   int total_deals = HistoryDealsTotal();
   for(int i = 0; i < total_deals; i++)
   {
      ulong deal_ticket = HistoryDealGetTicket(i);
      if(deal_ticket == 0) continue;
      string deal_symbol = HistoryDealGetString(deal_ticket, DEAL_SYMBOL);
      long deal_entry = HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);
      datetime deal_time = (datetime)HistoryDealGetInteger(deal_ticket, DEAL_TIME);
      if(deal_symbol == _Symbol && deal_entry == DEAL_ENTRY_OUT && deal_time > start_time && deal_time <= end_time)
      {
         if(WasInKillzone(deal_time, zone))
         {
            double deal_profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
            if(deal_profit > profit_threshold) return true;
         }
      }
   }
   return false;
}
//+------------------------------------------------------------------+
//| Helper to check if a time was in a specific killzone (added) |
//+------------------------------------------------------------------+
bool WasInKillzone(datetime t, string zone)
{
   datetime day_start = t - (t % 86400);
   MqlDateTime str;
   TimeToStruct(day_start, str);
   datetime start, end;
   if(zone == "London")
   {
      str.hour = 10 + TimeAdjustment;
      str.min = 0;
      str.sec = 0;
      start = StructToTime(str);
      str.hour = 13 + TimeAdjustment;
      str.min = 0;
      str.sec = 0;
      end = StructToTime(str);
   }
   else if(zone == "NY")
   {
      str.hour = 17 + TimeAdjustment;
      str.min = 30;
      str.sec = 0;
      start = StructToTime(str);
      str.hour = 19 + TimeAdjustment;
      str.min = 0;
      str.sec = 0;
      end = StructToTime(str);
   }
   else return false;
   return (t >= start && t < end);
}
//+------------------------------------------------------------------+
//| Find first swing low point for long trades |
//+------------------------------------------------------------------+
double FindSwingLowPoint(datetime fvg_time, double entry_price)
{
   int fvg_bar = iBarShift(_Symbol, PERIOD_CURRENT, fvg_time, true);
   if(fvg_bar < 1) return 0;
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   int max_search = MathMin(iBars(_Symbol, PERIOD_CURRENT) - 2, 100);
   for(int i = 1; i <= max_search; i++)
   {
      double low_i = iLow(_Symbol, PERIOD_CURRENT, i);
      double low_prev = iLow(_Symbol, PERIOD_CURRENT, i + 1);
      double low_next = iLow(_Symbol, PERIOD_CURRENT, i - 1);
      if(low_prev > low_i && low_next > low_i && low_i < entry_price)
      {
         return NormalizeDouble(low_i - tick_size, _Digits);
      }
   }
   return 0;
}
//+------------------------------------------------------------------+
//| Find first swing high point for short trades |
//+------------------------------------------------------------------+
double FindSwingHighPoint(datetime fvg_time, double entry_price)
{
   int fvg_bar = iBarShift(_Symbol, PERIOD_CURRENT, fvg_time, true);
   if(fvg_bar < 1) return 0;
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double spread = (double)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   int max_search = MathMin(iBars(_Symbol, PERIOD_CURRENT) - 2, 100);
   for(int i = 1; i <= max_search; i++)
   {
      double high_i = iHigh(_Symbol, PERIOD_CURRENT, i);
      double high_prev = iHigh(_Symbol, PERIOD_CURRENT, i + 1);
      double high_next = iHigh(_Symbol, PERIOD_CURRENT, i - 1);
      if(high_prev < high_i && high_next < high_i && high_i > entry_price)
      {
         return NormalizeDouble(high_i + tick_size + spread, _Digits);
      }
   }
   return 0;
}
//+------------------------------------------------------------------+
//| Plot trade number at the active level |
//+------------------------------------------------------------------+
// Updated signature (add param)
void PlotTradeNumber(string level_name, int trade_number, double level, datetime time, bool is_long, bool isBreakout = false)
{
   if(level <= 0) return; // Fixed: Use param 'level'
   string prefix = isBreakout ? "B" : ""; // Fixed: Prefix for label
   string label_text = prefix + IntegerToString(trade_number);
   string date_str = TimeToString(time, TIME_DATE); // Fixed: Use param 'time'
   string obj_name = date_str + " " + level_name + " Trade" + label_text; // Fixed: Build name with prefix
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double plot_price = is_long ? level - 3.0 * tick_size : level + 3.0 * tick_size; // Fixed: Position based on is_long, use 'level'
   color plot_color = (StringFind(level_name, "Low") >= 0) ?
                      (level_name == "AsiaLow" ? clrLightGray : level_name == "LondonLow" ? clrGold : clrRed) :
                      (level_name == "AsiaHigh" ? clrLightGray : level_name == "LondonHigh" ? clrGold : clrGreen);
   if(ObjectCreate(0, obj_name, OBJ_TEXT, 0, time, plot_price)) // Fixed: Use param 'time'
   {
      ObjectSetString(0, obj_name, OBJPROP_TEXT, label_text); // Fixed: Use prefixed label_text
      ObjectSetInteger(0, obj_name, OBJPROP_COLOR, plot_color);
      ObjectSetInteger(0, obj_name, OBJPROP_FONTSIZE, 8);
      ObjectSetString(0, obj_name, OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, obj_name, OBJPROP_ANCHOR, ANCHOR_CENTER);
      ObjectSetInteger(0, obj_name, OBJPROP_BACK, true);
      ObjectSetInteger(0, obj_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, obj_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Draw FVG rectangle (reversal) |
//+------------------------------------------------------------------+
void DrawFVGRectangle(datetime fvg_time, double gap_low, double gap_high)
{
   string date = TimeToString(fvg_time, TIME_DATE);
   string rect_name = date + " FVG*" + IntegerToString(fvg_time);
   datetime end_time = iTime(_Symbol, PERIOD_CURRENT, iBarShift(_Symbol, PERIOD_CURRENT, fvg_time, true) - 3);
   if(end_time <= fvg_time) end_time = fvg_time + PeriodSeconds(PERIOD_CURRENT) * 3;
   if(ObjectCreate(0, rect_name, OBJ_RECTANGLE, 0, fvg_time, gap_high, end_time, gap_low))
   {
      ObjectSetInteger(0, rect_name, OBJPROP_COLOR, clrLightGray);
      ObjectSetInteger(0, rect_name, OBJPROP_STYLE, STYLE_SOLID);
      ObjectSetInteger(0, rect_name, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, rect_name, OBJPROP_FILL, true);
      ObjectSetInteger(0, rect_name, OBJPROP_BACK, true);
      ObjectSetInteger(0, rect_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, rect_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Debug chart objects to verify line existence |
//+------------------------------------------------------------------+
void DebugChartObjects(string prefix)
{
   int total = ObjectsTotal(0, 0, -1);
   for(int i = 0; i < total; i++)
   {
      string name = ObjectName(0, i);
      if(StringFind(name, prefix) >= 0)
      {
         datetime time1 = (datetime)ObjectGetInteger(0, name, OBJPROP_TIME, 0);
         datetime time2 = (datetime)ObjectGetInteger(0, name, OBJPROP_TIME, 1);
         double price1 = ObjectGetDouble(0, name, OBJPROP_PRICE, 0);
         double price2 = ObjectGetDouble(0, name, OBJPROP_PRICE, 1);
         Print("Debug Object: ", name, " | Times: ", TimeToString(time1), " to ", TimeToString(time2), " | Prices: ", price1, " to ", price2);
      }
   }
}
//+------------------------------------------------------------------+
//| Delete old bias objects |
//+------------------------------------------------------------------+
void DeleteOldBiasObjects(string prev_date)
{
   int total = ObjectsTotal(0, 0, -1);
   for(int i = total - 1; i >= 0; i--)
   {
      string name = ObjectName(0, i);
      if(StringFind(name, prev_date + " Bias") >= 0)
      {
         ObjectDelete(0, name);
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Helper: Get kill zone times (hardcoded as in DrawSessionLines) |
//+------------------------------------------------------------------+
datetime GetLondonKillzoneStart()
{
   MqlDateTime str;
   TimeToStruct(TimeCurrent(), str);
   str.hour = 10 + TimeAdjustment;
   str.min = 0;
   str.sec = 0;
   return StructToTime(str);
}
datetime GetLondonKillzoneEnd()
{
   MqlDateTime str;
   TimeToStruct(TimeCurrent(), str);
   str.hour = 13 + TimeAdjustment;
   str.min = 0;
   str.sec = 0;
   return StructToTime(str);
}
datetime GetNYKillzoneStart()
{
   MqlDateTime str;
   TimeToStruct(TimeCurrent(), str);
   str.hour = 17 + TimeAdjustment;
   str.min = 30;
   str.sec = 0;
   return StructToTime(str);
}
datetime GetNYKillzoneEnd()
{
   MqlDateTime str;
   TimeToStruct(TimeCurrent(), str);
   str.hour = 19 + TimeAdjustment;
   str.min = 0;
   str.sec = 0;
   return StructToTime(str);
}
datetime GetNYOpen()
{
   MqlDateTime str;
   TimeToStruct(TimeCurrent(), str);
   str.hour = 8 + TimeAdjustment;
   str.min = 0;
   str.sec = 0;
   return StructToTime(str);
}
datetime GetCloseAll()
{
   MqlDateTime str;
   TimeToStruct(TimeCurrent(), str);
   str.hour = CloseAllHour;
   str.min = CloseAllMinutes;
   str.sec = 0;
   return StructToTime(str);
}
//+------------------------------------------------------------------+
//| Helper: Check if current M1 candle is in time range (include start, exclude end)|
//+------------------------------------------------------------------+
bool IsInTimeRange(datetime start, datetime end)
{
   datetime barOpen = iTime(_Symbol, PERIOD_M1, 0); // Current M1 bar open time
   MqlDateTime currentStruct, startStruct, endStruct;
   TimeToStruct(barOpen, currentStruct);
   TimeToStruct(start, startStruct);
   TimeToStruct(end, endStruct);
   int currentMin = currentStruct.hour * 60 + currentStruct.min;
   int startMin = startStruct.hour * 60 + startStruct.min;
   int endMin = endStruct.hour * 60 + endStruct.min;
   return (currentMin >= startMin && currentMin < endMin);
}
//+------------------------------------------------------------------+
//| Helper: Check if in any kill zone |
//+------------------------------------------------------------------+
bool IsInKillzone()
{
   return IsInTimeRange(GetLondonKillzoneStart(), GetLondonKillzoneEnd()) || IsInTimeRange(GetNYKillzoneStart(), GetNYKillzoneEnd());
}
//+------------------------------------------------------------------+
//| Helper: Get current kill zone type |
//+------------------------------------------------------------------+
string CurrentKillzone()
{
   if (IsInTimeRange(GetLondonKillzoneStart(), GetLondonKillzoneEnd())) return "London";
   if (IsInTimeRange(GetNYKillzoneStart(), GetNYKillzoneEnd())) return "NY";
   return "None";
}
//+------------------------------------------------------------------+
//| Draw session vertical lines and CloseAll line (CloseAll color changed to Red)|
//+------------------------------------------------------------------+
void DrawSessionLines()
{
   datetime current_time = TimeCurrent();
   string date = TimeToString(current_time, TIME_DATE);
   MqlDateTime str_AsiaStart, str_NYOpen, str_LondonSessionEnd, str_CloseAll;
   MqlDateTime str_LondonKillzoneStart, str_LondonKillzoneEnd, str_NYKillzoneStart, str_NYKillzoneEnd, str_GeneralNews;
   TimeToStruct(current_time, str_AsiaStart);
   TimeToStruct(current_time, str_NYOpen);
   TimeToStruct(current_time, str_LondonSessionEnd);
   TimeToStruct(current_time, str_CloseAll);
   TimeToStruct(current_time, str_LondonKillzoneStart);
   TimeToStruct(current_time, str_LondonKillzoneEnd);
   TimeToStruct(current_time, str_NYKillzoneStart);
   TimeToStruct(current_time, str_NYKillzoneEnd);
   TimeToStruct(current_time, str_GeneralNews);
   str_AsiaStart.hour = 3 + TimeAdjustment;
   str_AsiaStart.min = 0;
   str_AsiaStart.sec = 0;
   datetime time_AsiaStart = StructToTime(str_AsiaStart);
   str_NYOpen.hour = 8 + TimeAdjustment;
   str_NYOpen.min = 0;
   str_NYOpen.sec = 0;
   datetime time_NYOpen = StructToTime(str_NYOpen);
   str_LondonSessionEnd.hour = 14 + TimeAdjustment;
   str_LondonSessionEnd.min = 0;
   str_LondonSessionEnd.sec = 0;
   datetime time_LondonSessionEnd = StructToTime(str_LondonSessionEnd);
   str_CloseAll.hour = CloseAllHour;
   str_CloseAll.min = CloseAllMinutes;
   str_CloseAll.sec = 0;
   datetime time_CloseAll = StructToTime(str_CloseAll);
   str_LondonKillzoneStart.hour = 10 + TimeAdjustment;
   str_LondonKillzoneStart.min = 0;
   str_LondonKillzoneStart.sec = 0;
   datetime time_LondonKillzoneStart = StructToTime(str_LondonKillzoneStart);
   str_LondonKillzoneEnd.hour = 13 + TimeAdjustment;
   str_LondonKillzoneEnd.min = 0;
   str_LondonKillzoneEnd.sec = 0;
   datetime time_LondonKillzoneEnd = StructToTime(str_LondonKillzoneEnd);
   str_NYKillzoneStart.hour = 17 + TimeAdjustment;
   str_NYKillzoneStart.min = 30;
   str_NYKillzoneStart.sec = 0;
   datetime time_NYKillzoneStart = StructToTime(str_NYKillzoneStart);
   str_NYKillzoneEnd.hour = 19 + TimeAdjustment;
   str_NYKillzoneEnd.min = 0;
   str_NYKillzoneEnd.sec = 0;
   datetime time_NYKillzoneEnd = StructToTime(str_NYKillzoneEnd);
   str_GeneralNews.hour = 16 + TimeAdjustment;
   str_GeneralNews.min = 30;
   str_GeneralNews.sec = 0;
   datetime time_GeneralNews = StructToTime(str_GeneralNews);
   string lines[] = {"AsiaStart", "NYOpen", "LondonSessionEnd", "CloseAll", "LondonKillzoneStart", "LondonKillzoneEnd", "NYKillzoneStart", "NYKillzoneEnd", "GeneralNews"};
   datetime times[] = {time_AsiaStart, time_NYOpen, time_LondonSessionEnd, time_CloseAll, time_LondonKillzoneStart, time_LondonKillzoneEnd, time_NYKillzoneStart, time_NYKillzoneEnd, time_GeneralNews};
   color colors[] = {clrGainsboro, clrGainsboro, clrNavajoWhite, clrRed, clrLightGray, clrLightGray, clrLightGray, clrLightGray, clrPink}; // Changed CloseAll to clrRed
   int styles[] = {STYLE_DOT, STYLE_SOLID, STYLE_DOT, STYLE_DOT, STYLE_DOT, STYLE_DOT, STYLE_DOT, STYLE_DOT, STYLE_DOT};
   int widths[] = {1, 2, 1, 1, 1, 1, 1, 1, 1};
   for(int i = 0; i < ArraySize(lines); i++)
   {
      string name = date + " " + lines[i];
      if(ObjectFind(0, name) >= 0) continue;
      if(ObjectCreate(0, name, OBJ_VLINE, 0, times[i], 0))
      {
         ObjectSetInteger(0, name, OBJPROP_COLOR, colors[i]);
         ObjectSetInteger(0, name, OBJPROP_STYLE, styles[i]);
         ObjectSetInteger(0, name, OBJPROP_WIDTH, widths[i]);
         ObjectSetInteger(0, name, OBJPROP_BACK, true);
         ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
         ObjectSetInteger(0, name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Draw high/low lines for Asia, London, and Daily sessions (updated for NYOpen raid check and London flag) |
//+------------------------------------------------------------------+
void DrawHighLowLines()
{
   datetime current_time = TimeCurrent();
   string date = TimeToString(current_time, TIME_DATE);
   MqlDateTime str_AsiaStart, str_NYOpen, str_LondonSessionEnd, str_CloseAll, str_PrevNYOpen, str_LondonStart;
   TimeToStruct(current_time, str_AsiaStart);
   TimeToStruct(current_time, str_NYOpen);
   TimeToStruct(current_time, str_LondonSessionEnd);
   TimeToStruct(current_time, str_CloseAll);
   TimeToStruct(current_time, str_LondonStart);
   str_AsiaStart.hour = 3 + TimeAdjustment;
   str_AsiaStart.min = 0;
   str_AsiaStart.sec = 0;
   datetime time_AsiaStart = StructToTime(str_AsiaStart);
   str_NYOpen.hour = 8 + TimeAdjustment;
   str_NYOpen.min = 0;
   str_NYOpen.sec = 0;
   datetime time_NYOpen = StructToTime(str_NYOpen);
   str_LondonSessionEnd.hour = 14 + TimeAdjustment;
   str_LondonSessionEnd.min = 0;
   str_LondonSessionEnd.sec = 0;
   datetime time_LondonSessionEnd = StructToTime(str_LondonSessionEnd);
   str_CloseAll.hour = CloseAllHour;
   str_CloseAll.min = CloseAllMinutes;
   str_CloseAll.sec = 0;
   datetime time_CloseAll = StructToTime(str_CloseAll);
   str_LondonStart.hour = 8 + TimeAdjustment;
   str_LondonStart.min = 0;
   str_LondonStart.sec = 0;
   datetime time_LondonStart = StructToTime(str_LondonStart);
   datetime prev_day = current_time - 86400;
   TimeToStruct(prev_day, str_PrevNYOpen);
   while(str_PrevNYOpen.day_of_week == 0 || str_PrevNYOpen.day_of_week == 6)
   {
      prev_day -= 86400;
      TimeToStruct(prev_day, str_PrevNYOpen);
   }
   str_PrevNYOpen.hour = 8 + TimeAdjustment;
   str_PrevNYOpen.min = 0;
   str_PrevNYOpen.sec = 0;
   datetime time_PrevNYOpen = StructToTime(str_PrevNYOpen);
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   bool doReversals = (TradingStyle == OnlyReversals || TradingStyle == BothReversalsAndBreakouts);
   bool doBreakouts = (TradingStyle == OnlyBreakouts || TradingStyle == BothReversalsAndBreakouts);
   if(current_time >= time_NYOpen)
   {
      MqlRates rates[];
      int copied = CopyRates(_Symbol, PERIOD_M1, time_AsiaStart, time_NYOpen, rates);
      if(copied > 0)
      {
         AsiaHigh = rates[0].high;
         AsiaLow = rates[0].low;
         for(int i = 1; i < copied; i++)
         {
            if(rates[i].high > AsiaHigh) AsiaHigh = rates[i].high;
            if(rates[i].low < AsiaLow) AsiaLow = rates[i].low;
         }
         AsiaLowValidUntil = time_CloseAll;
         AsiaHighValidUntil = time_CloseAll;
         if(doBreakouts)
         {
            BreakoutAsiaLowValidUntil = time_CloseAll;
            BreakoutAsiaHighValidUntil = time_CloseAll;
         }
         DrawAsiaLines(time_AsiaStart, AsiaHigh, AsiaLow, date, time_CloseAll);
      }
      // New: Check NYOpen candle for immediate raid activation
      double nyopen_low = iLow(_Symbol, PERIOD_CURRENT, iBarShift(_Symbol, PERIOD_CURRENT, time_NYOpen, true));
      double nyopen_high = iHigh(_Symbol, PERIOD_CURRENT, iBarShift(_Symbol, PERIOD_CURRENT, time_NYOpen, true));
      if(AsiaLow > 0 && nyopen_low < AsiaLow - tick_size)
      {
         if(doReversals && !AsiaLowRaided)
         {
            AsiaLowRaided = true;
            AsiaLowRaidTime = time_NYOpen;
            if(ActiveLowLevel == DBL_MAX || AsiaLow < ActiveLowLevel)
            {
               ActiveLowLevel = AsiaLow;
               ActiveLowLevelName = "AsiaLow";
            }
            if(!AsiaLowCurrentRaidTime) AsiaLowCurrentRaidTime = time_NYOpen; // Sync on first
            if(EntryTypeReversals == firstCloseBeyondCandle && !AsiaLowWaitingForEntry) AsiaLowWaitingForEntry = true;
         }
         if(doBreakouts && !BreakoutAsiaLowRaided)
         {
            BreakoutAsiaLowRaided = true;
            BreakoutAsiaLowRaidTime = time_NYOpen;
            if(BreakoutActiveLowLevel == DBL_MAX || AsiaLow < BreakoutActiveLowLevel)
            {
               // Invalidate higher if any (for new day, none)
               BreakoutActiveLowLevel = AsiaLow;
               CurrentBreakoutLowLevelName = "AsiaLow";
               CurrentBreakoutLowRaidTime = BreakoutAsiaLowRaidTime;
               BreakoutLowWaitingForRetrace = false;
               BreakoutLowHasKey = false;
               CurrentBreakoutLowKeyLevel = 0;
            }
         }
         Print("NYOpen activated AsiaLow raid");
      }
      if(AsiaHigh > 0 && nyopen_high > AsiaHigh + tick_size)
      {
         if(doReversals && !AsiaHighRaided)
         {
            AsiaHighRaided = true;
            AsiaHighRaidTime = time_NYOpen;
            if(ActiveHighLevel == DBL_MIN || AsiaHigh > ActiveHighLevel)
            {
               ActiveHighLevel = AsiaHigh;
               ActiveHighLevelName = "AsiaHigh";
            }
            if(!AsiaHighCurrentRaidTime) AsiaHighCurrentRaidTime = time_NYOpen; // Sync on first
            if(EntryTypeReversals == firstCloseBeyondCandle && !AsiaHighWaitingForEntry) AsiaHighWaitingForEntry = true;
         }
         if(doBreakouts && !BreakoutAsiaHighRaided)
         {
            BreakoutAsiaHighRaided = true;
            BreakoutAsiaHighRaidTime = time_NYOpen;
            if(BreakoutActiveHighLevel == DBL_MIN || AsiaHigh > BreakoutActiveHighLevel)
            {
               BreakoutActiveHighLevel = AsiaHigh;
               CurrentBreakoutHighLevelName = "AsiaHigh";
               CurrentBreakoutHighRaidTime = BreakoutAsiaHighRaidTime;
               BreakoutHighWaitingForRetrace = false;
               BreakoutHighHasKey = false;
               CurrentBreakoutHighKeyLevel = 0;
            }
         }
         Print("NYOpen activated AsiaHigh raid");
      }
      if(DailyLow > 0 && nyopen_low < DailyLow - tick_size)
      {
         if(doReversals && !DailyLowRaided)
         {
            DailyLowRaided = true;
            DailyLowRaidTime = time_NYOpen;
            if(ActiveLowLevel == DBL_MAX || DailyLow < ActiveLowLevel)
            {
               ActiveLowLevel = DailyLow;
               ActiveLowLevelName = "DailyLow";
            }
            if(!DailyLowCurrentRaidTime) DailyLowCurrentRaidTime = time_NYOpen; // Sync on first
            if(EntryTypeReversals == firstCloseBeyondCandle && !DailyLowWaitingForEntry) DailyLowWaitingForEntry = true;
         }
         if(doBreakouts && !BreakoutDailyLowRaided)
         {
            BreakoutDailyLowRaided = true;
            BreakoutDailyLowRaidTime = time_NYOpen;
            if(BreakoutActiveLowLevel == DBL_MAX || DailyLow < BreakoutActiveLowLevel)
            {
               BreakoutActiveLowLevel = DailyLow;
               CurrentBreakoutLowLevelName = "DailyLow";
               CurrentBreakoutLowRaidTime = BreakoutDailyLowRaidTime;
               BreakoutLowWaitingForRetrace = false;
               BreakoutLowHasKey = false;
               CurrentBreakoutLowKeyLevel = 0;
            }
         }
         Print("NYOpen activated DailyLow raid");
      }
      if(DailyHigh > 0 && nyopen_high > DailyHigh + tick_size)
      {
         if(doReversals && !DailyHighRaided)
         {
            DailyHighRaided = true;
            DailyHighRaidTime = time_NYOpen;
            if(ActiveHighLevel == DBL_MIN || DailyHigh > ActiveHighLevel)
            {
               ActiveHighLevel = DailyHigh;
               ActiveHighLevelName = "DailyHigh";
            }
            if(!DailyHighCurrentRaidTime) DailyHighCurrentRaidTime = time_NYOpen; // Sync on first
            if(EntryTypeReversals == firstCloseBeyondCandle && !DailyHighWaitingForEntry) DailyHighWaitingForEntry = true;
         }
         if(doBreakouts && !BreakoutDailyHighRaided)
         {
            BreakoutDailyHighRaided = true;
            BreakoutDailyHighRaidTime = time_NYOpen;
            if(BreakoutActiveHighLevel == DBL_MIN || DailyHigh > BreakoutActiveHighLevel)
            {
               BreakoutActiveHighLevel = DailyHigh;
               CurrentBreakoutHighLevelName = "DailyHigh";
               CurrentBreakoutHighRaidTime = BreakoutDailyHighRaidTime;
               BreakoutHighWaitingForRetrace = false;
               BreakoutHighHasKey = false;
               CurrentBreakoutHighKeyLevel = 0;
            }
         }
         Print("NYOpen activated DailyHigh raid");
      }
   }
   if(current_time >= time_LondonSessionEnd)
   {
      MqlRates rates[];
      int copied = CopyRates(_Symbol, PERIOD_M1, time_LondonStart, time_LondonSessionEnd, rates);
      if(copied > 0)
      {
         LondonHigh = rates[0].high;
         LondonLow = rates[0].low;
         for(int i = 1; i < copied; i++)
         {
            if(rates[i].high > LondonHigh) LondonHigh = rates[i].high;
            if(rates[i].low < LondonLow) LondonLow = rates[i].low;
         }
         LondonLowValidUntil = time_CloseAll;
         LondonHighValidUntil = time_CloseAll;
         if(doBreakouts)
         {
            BreakoutLondonLowValidUntil = time_CloseAll;
            BreakoutLondonHighValidUntil = time_CloseAll;
         }
         DrawLondonLines(time_LondonStart, LondonHigh, LondonLow, date, time_CloseAll);
         if(doReversals) LondonLevelsSet = true;
         Print("London levels set - TP update pending");
   
         // Enhanced: Scan from LondonStart to current for first raid (during/after session)
         int london_shift = iBarShift(_Symbol, PERIOD_CURRENT, time_LondonStart, true);
         if(london_shift >= 0)
         {
            for(int s = 1; s <= london_shift; s++) // From recent to old
            {
               double bar_low = iLow(_Symbol, PERIOD_CURRENT, s);
               double bar_high = iHigh(_Symbol, PERIOD_CURRENT, s);
               datetime bar_time = iTime(_Symbol, PERIOD_CURRENT, s);
               if(LondonLow > 0 && bar_low < LondonLow - tick_size)
               {
                  if(doReversals && !LondonLowRaided)
                  {
                     LondonLowRaided = true;
                     LondonLowRaidTime = bar_time;
                     if(!LondonLowCurrentRaidTime) LondonLowCurrentRaidTime = bar_time; // First breach
                     if(ActiveLowLevel == DBL_MAX || LondonLow < ActiveLowLevel)
                     {
                        ActiveLowLevel = LondonLow;
                        ActiveLowLevelName = "LondonLow";
                     }
                     if (RaidMustBeInKillzone) raidedLowInLondon = true;
                     if(EntryTypeReversals == firstCloseBeyondCandle && !LondonLowWaitingForEntry) LondonLowWaitingForEntry = true;
                     Print("London raid: First low breach at ", TimeToString(bar_time));
                     break;
                  }
                  if(doBreakouts && !BreakoutLondonLowRaided)
                  {
                     BreakoutLondonLowRaided = true;
                     BreakoutLondonLowRaidTime = bar_time;
                     if(BreakoutActiveLowLevel == DBL_MAX || LondonLow < BreakoutActiveLowLevel)
                     {
                        BreakoutActiveLowLevel = LondonLow;
                        CurrentBreakoutLowLevelName = "LondonLow";
                        CurrentBreakoutLowRaidTime = BreakoutLondonLowRaidTime;
                        BreakoutLowWaitingForRetrace = false;
                        BreakoutLowHasKey = false;
                        CurrentBreakoutLowKeyLevel = 0;
                     }
                     if (RaidMustBeInKillzone) BreakoutRaidedLowInLondon = true;
                     Print("Breakout London raid: First low breach at ", TimeToString(bar_time));
                     break;
                  }
               }
               if(LondonHigh > 0 && bar_high > LondonHigh + tick_size)
               {
                  if(doReversals && !LondonHighRaided)
                  {
                     LondonHighRaided = true;
                     LondonHighRaidTime = bar_time;
                     if(!LondonHighCurrentRaidTime) LondonHighCurrentRaidTime = bar_time; // First breach
                     if(ActiveHighLevel == DBL_MIN || LondonHigh > ActiveHighLevel)
                     {
                        ActiveHighLevel = LondonHigh;
                        ActiveHighLevelName = "LondonHigh";
                     }
                     if (RaidMustBeInKillzone) raidedHighInLondon = true;
                     if(EntryTypeReversals == firstCloseBeyondCandle && !LondonHighWaitingForEntry) LondonHighWaitingForEntry = true;
                     Print("London raid: First high breach at ", TimeToString(bar_time));
                     break;
                  }
                  if(doBreakouts && !BreakoutLondonHighRaided)
                  {
                     BreakoutLondonHighRaided = true;
                     BreakoutLondonHighRaidTime = bar_time;
                     if(BreakoutActiveHighLevel == DBL_MIN || LondonHigh > BreakoutActiveHighLevel)
                     {
                        BreakoutActiveHighLevel = LondonHigh;
                        CurrentBreakoutHighLevelName = "LondonHigh";
                        CurrentBreakoutHighRaidTime = BreakoutLondonHighRaidTime;
                        BreakoutHighWaitingForRetrace = false;
                        BreakoutHighHasKey = false;
                        CurrentBreakoutHighKeyLevel = 0;
                     }
                     if (RaidMustBeInKillzone) BreakoutRaidedHighInLondon = true;
                     Print("Breakout London raid: First high breach at ", TimeToString(bar_time));
                     break;
                  }
               }
            }
         }
      }
   }
   if(current_time >= time_NYOpen)
   {
      MqlRates rates[];
      int copied = CopyRates(_Symbol, PERIOD_M1, time_PrevNYOpen, time_NYOpen, rates);
      if(copied > 0)
      {
         DailyHigh = rates[0].high;
         DailyLow = rates[0].low;
         for(int i = 1; i < copied; i++)
         {
            if(rates[i].high > DailyHigh) DailyHigh = rates[i].high;
            if(rates[i].low < DailyLow) DailyLow = rates[i].low;
         }
         DailyLowValidUntil = time_CloseAll;
         DailyHighValidUntil = time_CloseAll;
         if(doBreakouts)
         {
            BreakoutDailyLowValidUntil = time_CloseAll;
            BreakoutDailyHighValidUntil = time_CloseAll;
         }
         if(DailyHigh > 0 && DailyLow > 0)
         {
            DrawDailyLines(time_PrevNYOpen, DailyHigh, DailyLow, date, time_CloseAll);
         }
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Draw Asia high/low lines |
//+------------------------------------------------------------------+
void DrawAsiaLines(datetime start, double high, double low, string date, datetime close_all)
{
   datetime current_time = TimeCurrent();
   if(high <= 0 || low <= 0 || start >= close_all) return;
   datetime current_bar_time = iTime(_Symbol, PERIOD_CURRENT, 0);
   datetime new_end_time = MathMin(current_bar_time, close_all);
   string high_name = date + " AsiaHigh";
   long chart_id = 0;
   if(ObjectFind(chart_id, high_name) < 0)
   {
      if(ObjectCreate(chart_id, high_name, OBJ_TREND, 0, start, high, new_end_time, high))
      {
         ObjectSetInteger(chart_id, high_name, OBJPROP_COLOR, clrLightGray);
         ObjectSetInteger(chart_id, high_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, high_name, OBJPROP_WIDTH, 2);
         ObjectSetInteger(chart_id, high_name, OBJPROP_BACK, true);
         ObjectSetInteger(chart_id, high_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(chart_id, high_name, OBJPROP_SELECTED, false);
         ObjectSetInteger(chart_id, high_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
         ObjectSetInteger(chart_id, high_name, OBJPROP_RAY_RIGHT, false);
      }
   }
   else
   {
      datetime current_high_end = (datetime)ObjectGetInteger(chart_id, high_name, OBJPROP_TIME, 1);
      if(new_end_time > current_high_end && current_time <= close_all)
      {
         ObjectSetInteger(chart_id, high_name, OBJPROP_TIME, 1, new_end_time);
      }
   }
   string low_name = date + " AsiaLow";
   if(ObjectFind(chart_id, low_name) < 0)
   {
      if(ObjectCreate(chart_id, low_name, OBJ_TREND, 0, start, low, new_end_time, low))
      {
         ObjectSetInteger(chart_id, low_name, OBJPROP_COLOR, clrLightGray);
         ObjectSetInteger(chart_id, low_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, low_name, OBJPROP_WIDTH, 2);
         ObjectSetInteger(chart_id, low_name, OBJPROP_BACK, true);
         ObjectSetInteger(chart_id, low_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(chart_id, low_name, OBJPROP_SELECTED, false);
         ObjectSetInteger(chart_id, low_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
         ObjectSetInteger(chart_id, low_name, OBJPROP_RAY_RIGHT, false);
      }
   }
   else
   {
      datetime current_low_end = (datetime)ObjectGetInteger(chart_id, low_name, OBJPROP_TIME, 1);
      if(new_end_time > current_low_end && current_time <= close_all)
      {
         ObjectSetInteger(chart_id, low_name, OBJPROP_TIME, 1, new_end_time);
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Draw London high/low lines |
//+------------------------------------------------------------------+
void DrawLondonLines(datetime start, double high, double low, string date, datetime close_all)
{
   datetime current_time = TimeCurrent();
   if(high <= 0 || low <= 0 || start >= close_all) return;
   datetime current_bar_time = iTime(_Symbol, PERIOD_CURRENT, 0);
   datetime new_end_time = MathMin(current_bar_time, close_all);
   string high_name = date + " LondonHigh";
   long chart_id = 0;
   if(ObjectFind(chart_id, high_name) < 0)
   {
      if(ObjectCreate(chart_id, high_name, OBJ_TREND, 0, start, high, new_end_time, high))
      {
         ObjectSetInteger(chart_id, high_name, OBJPROP_COLOR, clrGold);
         ObjectSetInteger(chart_id, high_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, high_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(chart_id, high_name, OBJPROP_BACK, true);
         ObjectSetInteger(chart_id, high_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(chart_id, high_name, OBJPROP_SELECTED, false);
         ObjectSetInteger(chart_id, high_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
         ObjectSetInteger(chart_id, high_name, OBJPROP_RAY_RIGHT, false);
      }
   }
   else
   {
      datetime current_high_end = (datetime)ObjectGetInteger(chart_id, high_name, OBJPROP_TIME, 1);
      if(new_end_time > current_high_end && current_time <= close_all)
      {
         ObjectSetInteger(chart_id, high_name, OBJPROP_TIME, 1, new_end_time);
      }
   }
   string low_name = date + " LondonLow";
   if(ObjectFind(chart_id, low_name) < 0)
   {
      if(ObjectCreate(chart_id, low_name, OBJ_TREND, 0, start, low, new_end_time, low))
      {
         ObjectSetInteger(chart_id, low_name, OBJPROP_COLOR, clrGold);
         ObjectSetInteger(chart_id, low_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, low_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(chart_id, low_name, OBJPROP_BACK, true);
         ObjectSetInteger(chart_id, low_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(chart_id, low_name, OBJPROP_SELECTED, false);
         ObjectSetInteger(chart_id, low_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
         ObjectSetInteger(chart_id, low_name, OBJPROP_RAY_RIGHT, false);
      }
   }
   else
   {
      datetime current_low_end = (datetime)ObjectGetInteger(chart_id, low_name, OBJPROP_TIME, 1);
      if(new_end_time > current_low_end && current_time <= close_all)
      {
         ObjectSetInteger(chart_id, low_name, OBJPROP_TIME, 1, new_end_time);
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Close all positions (new helper for CloseAll) |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         trade.PositionClose(ticket);
      }
   }
   // Reset breakout tickets
   CurrentBreakoutShortTicket = 0;
   CurrentBreakoutLongTicket = 0;
}
//+------------------------------------------------------------------+
//| Draw Daily high/low lines |
//+------------------------------------------------------------------+
void DrawDailyLines(datetime start, double high, double low, string date, datetime close_all)
{
   datetime current_time = TimeCurrent();
   if(high <= 0 || low <= 0 || start >= close_all) return;
   datetime current_bar_time = iTime(_Symbol, PERIOD_CURRENT, 0);
   datetime new_end_time = MathMin(current_bar_time, close_all);
   string high_name = date + " DailyHigh";
   long chart_id = 0;
   if(ObjectFind(chart_id, high_name) < 0)
   {
      if(ObjectCreate(chart_id, high_name, OBJ_TREND, 0, start, high, new_end_time, high))
      {
         ObjectSetInteger(chart_id, high_name, OBJPROP_COLOR, clrGreen);
         ObjectSetInteger(chart_id, high_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, high_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(chart_id, high_name, OBJPROP_BACK, true);
         ObjectSetInteger(chart_id, high_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(chart_id, high_name, OBJPROP_SELECTED, false);
         ObjectSetInteger(chart_id, high_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
         ObjectSetInteger(chart_id, high_name, OBJPROP_RAY_RIGHT, false);
      }
   }
   else
   {
      datetime current_high_end = (datetime)ObjectGetInteger(chart_id, high_name, OBJPROP_TIME, 1);
      if(new_end_time > current_high_end && current_time <= close_all)
      {
         ObjectSetInteger(chart_id, high_name, OBJPROP_TIME, 1, new_end_time);
      }
   }
   string low_name = date + " DailyLow";
   if(ObjectFind(chart_id, low_name) < 0)
   {
      if(ObjectCreate(chart_id, low_name, OBJ_TREND, 0, start, low, new_end_time, low))
      {
         ObjectSetInteger(chart_id, low_name, OBJPROP_COLOR, clrRed);
         ObjectSetInteger(chart_id, low_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(chart_id, low_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(chart_id, low_name, OBJPROP_BACK, true);
         ObjectSetInteger(chart_id, low_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(chart_id, low_name, OBJPROP_SELECTED, false);
         ObjectSetInteger(chart_id, low_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
         ObjectSetInteger(chart_id, low_name, OBJPROP_RAY_RIGHT, false);
      }
   }
   else
   {
      datetime current_low_end = (datetime)ObjectGetInteger(chart_id, low_name, OBJPROP_TIME, 1);
      if(new_end_time > current_low_end && current_time <= close_all)
      {
         ObjectSetInteger(chart_id, low_name, OBJPROP_TIME, 1, new_end_time);
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Calculate TP price based on TPType (for reversals) |
//+------------------------------------------------------------------+
double CalculateTP(bool is_long, double entry_price, double sl_price, double sl_distance, string current_level_name)
{
   double tp_multiple_dist = ReversalTPMultiple * sl_distance;
   double tp_multiple_price = is_long ? entry_price + tp_multiple_dist : entry_price - tp_multiple_dist;
   double opp_tp = 0.0;
   if(TPTypeReversals == OppositeLQ || TPTypeReversals == closestOppLQvsTPMultiple)
   {
      // Get closest opposite level (!raided, on correct side of entry)
      double candidates[3];
      bool raided_flags[3];
      if(is_long) // Long from low: target closest high > entry, !raided
      {
         candidates[0] = AsiaHigh; candidates[1] = LondonHigh; candidates[2] = DailyHigh;
         raided_flags[0] = AsiaHighRaided; raided_flags[1] = LondonHighRaided; raided_flags[2] = DailyHighRaided;
      }
      else // Short from high: target closest low < entry, !raided
      {
         candidates[0] = AsiaLow; candidates[1] = LondonLow; candidates[2] = DailyLow;
         raided_flags[0] = AsiaLowRaided; raided_flags[1] = LondonLowRaided; raided_flags[2] = DailyLowRaided;
      }
      double closest_dist = DBL_MAX;
      for(int i = 0; i < 3; i++)
      {
         bool on_right_side = is_long ? (candidates[i] > entry_price) : (candidates[i] < entry_price);
         if(on_right_side && !raided_flags[i])
         {
            double dist = MathAbs(candidates[i] - entry_price);
            if(dist < closest_dist)
            {
               closest_dist = dist;
               opp_tp = candidates[i];
            }
         }
      }
   }
   if(TPTypeReversals == OppositeLQ)
   {
      return (opp_tp > 0.0) ? opp_tp : tp_multiple_price; // Fallback if no opposite
   }
   else if(TPTypeReversals == closestOppLQvsTPMultiple)
   {
      if(opp_tp > 0.0)
      {
         double opp_dist = MathAbs(opp_tp - entry_price);
         return (opp_dist < tp_multiple_dist) ? opp_tp : tp_multiple_price;
      }
      return tp_multiple_price; // No opposite
   }
   else // TPMultiple
   {
      return tp_multiple_price;
   }
}
//+------------------------------------------------------------------+
//| Update TP for open positions after London levels (new, for reversals) |
//+------------------------------------------------------------------+
void UpdateTPAfterLondon()
{
   if(TPTypeReversals == TPMultiple || LondonLevelsUpdated) return; // Skip if not applicable
   int total = PositionsTotal();
   for(int i = 0; i < total; i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
      {
         string comment = PositionGetString(POSITION_COMMENT);
         if(StringFind(comment, "Breakout") >= 0) continue; // Skip breakouts
         bool is_long = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY;
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double current_tp = PositionGetDouble(POSITION_TP);
         double sl = PositionGetDouble(POSITION_SL);
         double sl_dist = MathAbs(entry - sl);
         string dummy_level = ""; // Not used for TP calc
         double new_tp = CalculateTP(is_long, entry, sl, sl_dist, dummy_level);
         double current_dist = MathAbs(current_tp - entry);
         double new_dist = MathAbs(new_tp - entry);
         if((is_long && new_tp > current_tp && new_dist < current_dist) || (!is_long && new_tp < current_tp && new_dist < current_dist))
         {
            trade.PositionModify(ticket, sl, new_tp);
            Print("Updated TP for ticket ", ticket, " to ", new_tp);
         }
      }
   }
   LondonLevelsUpdated = true;
}
//+------------------------------------------------------------------+
//| Draw bias dot for the day (modified to move vertically with price)|
//+------------------------------------------------------------------+
void DrawBiasDot(string date)
{
   string bias = DetermineBias();
   color dot_color = (bias == "Bullish") ? clrLime : (bias == "Bearish") ? clrRed : clrLightGray;
   if(BiasCandle2Low == 0) return;
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double dot_price = SymbolInfoDouble(_Symbol, SYMBOL_BID); // Updated to current Bid (added)
   int tmp_x, y_dot;
   datetime current_bar_time = iTime(_Symbol, PERIOD_CURRENT, 0);
   ChartTimePriceToXY(0, 0, current_bar_time, dot_price, tmp_x, y_dot);
   long chart_width = ChartGetInteger(0, CHART_WIDTH_IN_PIXELS);
   int candle_pixel_width = 10;
   int space_pixels = 4;
   int right_margin = 20;
   int candle2_x = (int)chart_width - right_margin - candle_pixel_width;
   int dot_x = candle2_x + candle_pixel_width + 4;
   string dot_name = date + " BiasDot";
   if(ObjectFind(0, dot_name) >= 0)
   {
      // Update position if exists (added for dynamic movement)
      ObjectSetInteger(0, dot_name, OBJPROP_XDISTANCE, dot_x);
      ObjectSetInteger(0, dot_name, OBJPROP_YDISTANCE, y_dot);
   }
   else
   {
      if(ObjectCreate(0, dot_name, OBJ_LABEL, 0, 0, 0))
      {
         ObjectSetInteger(0, dot_name, OBJPROP_XDISTANCE, dot_x);
         ObjectSetInteger(0, dot_name, OBJPROP_YDISTANCE, y_dot);
         ObjectSetString(0, dot_name, OBJPROP_TEXT, CharToString(159));
         ObjectSetString(0, dot_name, OBJPROP_FONT, "Wingdings");
         ObjectSetInteger(0, dot_name, OBJPROP_FONTSIZE, 25);
         ObjectSetInteger(0, dot_name, OBJPROP_COLOR, dot_color);
         ObjectSetInteger(0, dot_name, OBJPROP_ANCHOR, ANCHOR_CENTER);
         ObjectSetInteger(0, dot_name, OBJPROP_BACK, true);
         ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Draw bias candles for the day |
//+------------------------------------------------------------------+
void DrawBiasCandles()
{
   long chart_width = ChartGetInteger(0, CHART_WIDTH_IN_PIXELS);
   long chart_height = ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS);
   if(chart_width <= 0 || chart_height <= 0) return;
   datetime latest_time = iTime(_Symbol, PERIOD_CURRENT, 0);
   string date = TimeToString(latest_time, TIME_DATE);
   datetime ref_time = latest_time;
   int tmp_x;
   int candle_pixel_width = 10;
   int space_pixels = 4;
   int right_margin = 20;
   int wick_pixel_width = 1;
   // Calculate positions: older candle (BiasCandle1) on left, newer candle (BiasCandle2) on right
   int older_x = (int)chart_width - right_margin - (2 * candle_pixel_width + space_pixels);
   int newer_x = older_x + candle_pixel_width + space_pixels;
   // Delete previous day's bias candles on new day
   static datetime last_drawn_date = 0;
   datetime current_time = TimeCurrent();
   string current_date = TimeToString(current_time, TIME_DATE);
   if(current_date != TimeToString(last_drawn_date, TIME_DATE))
   {
      DeleteOldBiasObjects(TimeToString(last_drawn_date, TIME_DATE));
      last_drawn_date = current_time;
   }
   // Older candle (BiasCandle1, second to last)
   string older_name = date + " BiasOlder";
   ObjectDelete(0, older_name);
   ObjectDelete(0, older_name + "_WickTop");
   ObjectDelete(0, older_name + "_WickBottom");
   if(BiasCandle1Open != 0 && BiasCandle1Close != 0)
   {
      bool is_bullish1 = BiasCandle1Close > BiasCandle1Open;
      color wick_color1, body_color1, border_color1;
      if(colorOfDailyDrawnCandles == BlackWhite)
      {
         wick_color1 = clrBlack;
         body_color1 = is_bullish1 ? clrWhite : clrBlack;
         border_color1 = clrBlack;
      }
      else
      {
         wick_color1 = is_bullish1 ? clrLime : clrRed;
         body_color1 = is_bullish1 ? clrLime : clrRed;
         border_color1 = is_bullish1 ? clrLime : clrRed;
      }
      double body_top_price = MathMax(BiasCandle1Open, BiasCandle1Close);
      double body_bottom_price = MathMin(BiasCandle1Open, BiasCandle1Close);
      int y_body_top, y_body_bottom, y_high, y_low;
      ChartTimePriceToXY(0, 0, ref_time, body_top_price, tmp_x, y_body_top);
      ChartTimePriceToXY(0, 0, ref_time, body_bottom_price, tmp_x, y_body_bottom);
      ChartTimePriceToXY(0, 0, ref_time, BiasCandle1High, tmp_x, y_high);
      ChartTimePriceToXY(0, 0, ref_time, BiasCandle1Low, tmp_x, y_low);
      // Body
      if(ObjectCreate(0, older_name, OBJ_RECTANGLE_LABEL, 0, 0, 0))
      {
         ObjectSetInteger(0, older_name, OBJPROP_XDISTANCE, older_x);
         ObjectSetInteger(0, older_name, OBJPROP_YDISTANCE, MathMin(y_body_top, y_body_bottom));
         ObjectSetInteger(0, older_name, OBJPROP_XSIZE, candle_pixel_width);
         ObjectSetInteger(0, older_name, OBJPROP_YSIZE, MathAbs(y_body_bottom - y_body_top));
         ObjectSetInteger(0, older_name, OBJPROP_BGCOLOR, body_color1);
         ObjectSetInteger(0, older_name, OBJPROP_BORDER_COLOR, border_color1);
         ObjectSetInteger(0, older_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, older_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, older_name, OBJPROP_FILL, true);
         ObjectSetInteger(0, older_name, OBJPROP_BACK, true);
         ObjectSetInteger(0, older_name, OBJPROP_SELECTABLE, false);
      }
      // Upper Wick
      if(y_high < y_body_top)
      {
         if(ObjectCreate(0, older_name + "_WickTop", OBJ_RECTANGLE_LABEL, 0, 0, 0))
         {
            int wick_x = older_x + candle_pixel_width / 2 - wick_pixel_width / 2;
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_XDISTANCE, wick_x);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_YDISTANCE, y_high);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_XSIZE, wick_pixel_width);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_YSIZE, y_body_top - y_high);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_BGCOLOR, wick_color1);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_BORDER_COLOR, wick_color1);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_FILL, true);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_BACK, true);
            ObjectSetInteger(0, older_name + "_WickTop", OBJPROP_SELECTABLE, false);
         }
      }
      // Lower Wick
      if(y_low > y_body_bottom)
      {
         if(ObjectCreate(0, older_name + "_WickBottom", OBJ_RECTANGLE_LABEL, 0, 0, 0))
         {
            int wick_x = older_x + candle_pixel_width / 2 - wick_pixel_width / 2;
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_XDISTANCE, wick_x);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_YDISTANCE, y_body_bottom);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_XSIZE, wick_pixel_width);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_YSIZE, y_low - y_body_bottom);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_BGCOLOR, wick_color1);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_BORDER_COLOR, wick_color1);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_FILL, true);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_BACK, true);
            ObjectSetInteger(0, older_name + "_WickBottom", OBJPROP_SELECTABLE, false);
         }
      }
   }
   // Newer candle (BiasCandle2, last closed)
   string newer_name = date + " BiasNewer";
   ObjectDelete(0, newer_name);
   ObjectDelete(0, newer_name + "_WickTop");
   ObjectDelete(0, newer_name + "_WickBottom");
   if(BiasCandle2Open != 0 && BiasCandle2Close != 0)
   {
      bool is_bullish2 = BiasCandle2Close > BiasCandle2Open;
      color wick_color2, body_color2, border_color2;
      if(colorOfDailyDrawnCandles == BlackWhite)
      {
         wick_color2 = clrBlack;
         body_color2 = is_bullish2 ? clrWhite : clrBlack;
         border_color2 = clrBlack;
      }
      else
      {
         wick_color2 = is_bullish2 ? clrLime : clrRed;
         body_color2 = is_bullish2 ? clrLime : clrRed;
         border_color2 = is_bullish2 ? clrLime : clrRed;
      }
      double body_top_price = MathMax(BiasCandle2Open, BiasCandle2Close);
      double body_bottom_price = MathMin(BiasCandle2Open, BiasCandle2Close);
      int y_body_top, y_body_bottom, y_high, y_low;
      ChartTimePriceToXY(0, 0, ref_time, body_top_price, tmp_x, y_body_top);
      ChartTimePriceToXY(0, 0, ref_time, body_bottom_price, tmp_x, y_body_bottom);
      ChartTimePriceToXY(0, 0, ref_time, BiasCandle2High, tmp_x, y_high);
      ChartTimePriceToXY(0, 0, ref_time, BiasCandle2Low, tmp_x, y_low);
      // Body
      if(ObjectCreate(0, newer_name, OBJ_RECTANGLE_LABEL, 0, 0, 0))
      {
         ObjectSetInteger(0, newer_name, OBJPROP_XDISTANCE, newer_x);
         ObjectSetInteger(0, newer_name, OBJPROP_YDISTANCE, MathMin(y_body_top, y_body_bottom));
         ObjectSetInteger(0, newer_name, OBJPROP_XSIZE, candle_pixel_width);
         ObjectSetInteger(0, newer_name, OBJPROP_YSIZE, MathAbs(y_body_bottom - y_body_top));
         ObjectSetInteger(0, newer_name, OBJPROP_BGCOLOR, body_color2);
         ObjectSetInteger(0, newer_name, OBJPROP_BORDER_COLOR, border_color2);
         ObjectSetInteger(0, newer_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, newer_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, newer_name, OBJPROP_FILL, true);
         ObjectSetInteger(0, newer_name, OBJPROP_BACK, true);
         ObjectSetInteger(0, newer_name, OBJPROP_SELECTABLE, false);
      }
      // Upper Wick
      if(y_high < y_body_top)
      {
         if(ObjectCreate(0, newer_name + "_WickTop", OBJ_RECTANGLE_LABEL, 0, 0, 0))
         {
            int wick_x = newer_x + candle_pixel_width / 2 - wick_pixel_width / 2;
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_XDISTANCE, wick_x);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_YDISTANCE, y_high);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_XSIZE, wick_pixel_width);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_YSIZE, y_body_top - y_high);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_BGCOLOR, wick_color2);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_BORDER_COLOR, wick_color2);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_FILL, true);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_BACK, true);
            ObjectSetInteger(0, newer_name + "_WickTop", OBJPROP_SELECTABLE, false);
         }
      }
      // Lower Wick
      if(y_low > y_body_bottom)
      {
         if(ObjectCreate(0, newer_name + "_WickBottom", OBJ_RECTANGLE_LABEL, 0, 0, 0))
         {
            int wick_x = newer_x + candle_pixel_width / 2 - wick_pixel_width / 2;
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_XDISTANCE, wick_x);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_YDISTANCE, y_body_bottom);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_XSIZE, wick_pixel_width);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_YSIZE, y_low - y_body_bottom);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_BGCOLOR, wick_color2);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_BORDER_COLOR, wick_color2);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_FILL, true);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_BACK, true);
            ObjectSetInteger(0, newer_name + "_WickBottom", OBJPROP_SELECTABLE, false);
         }
      }
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Check for session breakouts (empty, no line updates) |
//+------------------------------------------------------------------+
void CheckAsiaBreakouts(datetime start, datetime session_end, double high, double low, string date) {}
void CheckLondonBreakouts(datetime start, datetime session_end, double high, double low, string date) {}
void CheckDailyBreakouts(datetime start, datetime session_end, datetime next_day_end, double high, double low, string date) {}
//+------------------------------------------------------------------+
//| Expert initialization function (added EMA handle) |
//+------------------------------------------------------------------+
int OnInit()
{
   ema_handle = iMA(_Symbol, PERIOD_D1, EMAValue, 0, MODE_EMA, PRICE_CLOSE); // Added
   // Validate StopLossMode
   ENUM_STOPLOSS_MODE runtimeSLModeReversals = SLModeReversals; // Local copy for safety
   if(SLModeReversals != CandleMidSL && SLModeReversals != GapBoundarySL && SLModeReversals != SwingPointSL && SLModeReversals != middleOfVFGSL && SLModeReversals != extremeOfRaid)
   {
      runtimeSLModeReversals = CandleMidSL; // Enforce safe default
      Print("WARNING: Invalid SLModeReversals '", EnumToString(SLModeReversals), "'. Fallback to CandleMidSL. Check inputs.");
   }
   ENUM_STOPLOSS_MODE runtimeSLModeBreakouts = SLModeBreakouts;
   if(SLModeBreakouts != SwingPointSL)
   {
      runtimeSLModeBreakouts = SwingPointSL;
      Print("WARNING: SLModeBreakouts must be SwingPointSL. Forced.");
   }
   DrawSessionLines();
   DrawHighLowLines();
   DebugChartObjects(TimeToString(TimeCurrent(), TIME_DATE));
   ChartSetInteger(0, CHART_SHIFT, true);
   ChartSetDouble(0, CHART_SHIFT_SIZE, 20.0);
   last_daily_time = iTime(_Symbol, PERIOD_D1, 0);
   return(INIT_SUCCEEDED);
}
//+------------------------------------------------------------------+
//| Expert deinitialization function |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // ObjectsDeleteAll(0, -1, -1); // Commented out to keep lines and trade numbers
   if(ema_handle != INVALID_HANDLE) IndicatorRelease(ema_handle); // Added release
   if(_Period == PERIOD_D1) ObjectDelete(0, "DailyEMA"); // Clean up EMA line on deinit only on D1
}
//+------------------------------------------------------------------+
//| Chart event function |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
   if(id == CHARTEVENT_CHART_CHANGE)
   {
      DetermineBias();
      DrawBiasCandles();
      DrawBiasDot(TimeToString(TimeCurrent(), TIME_DATE));
   }
}
//+------------------------------------------------------------------+
//| Draw or update the daily EMA line on the chart (added) |
//+------------------------------------------------------------------+
void DrawDailyEMALine()
{
   if(_Period != PERIOD_D1) return; // Only draw on D1 chart
   if(ema_handle == INVALID_HANDLE) return;
   double ema_buf[1];
   if(CopyBuffer(ema_handle, 0, 1, 1, ema_buf) < 1) return;
   double daily_ema = ema_buf[0]; // EMA of last closed daily bar
   string obj_name = "DailyEMA";
   if(ObjectFind(0, obj_name) < 0)
   {
      if(ObjectCreate(0, obj_name, OBJ_HLINE, 0, 0, daily_ema))
      {
         ObjectSetInteger(0, obj_name, OBJPROP_COLOR, clrBlue);
         ObjectSetInteger(0, obj_name, OBJPROP_STYLE, STYLE_SOLID);
         ObjectSetInteger(0, obj_name, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, obj_name, OBJPROP_BACK, true);
         ObjectSetInteger(0, obj_name, OBJPROP_SELECTABLE, true);
         ObjectSetInteger(0, obj_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
      }
   }
   else
   {
      ObjectSetDouble(0, obj_name, OBJPROP_PRICE, daily_ema);
   }
   ChartRedraw(0);
}
//+------------------------------------------------------------------+
//| Expert tick function (major updates: resets, duplicates, TP update, CanOpenNewTrade) |
//+------------------------------------------------------------------+
void OnTick()
{
   bool doReversals = (TradingStyle == OnlyReversals || TradingStyle == BothReversalsAndBreakouts);
   bool doBreakouts = (TradingStyle == OnlyBreakouts || TradingStyle == BothReversalsAndBreakouts);
   datetime current_time = TimeCurrent();
   datetime time_CloseAll = GetCloseAll();
   // New: CloseAll check
   MqlDateTime dt;
   TimeToStruct(current_time + TimeAdjustment * 3600, dt); // Adjust for input
   datetime close_all_time = StructToTime(dt);
   dt.hour = CloseAllHour;
   dt.min = CloseAllMinutes;
   dt.sec = 0;
   close_all_time = StructToTime(dt);
   if(current_time >= close_all_time)
   {
      CloseAllPositions();
      return;
   }
   if(current_time >= time_CloseAll && HasOpenPosition())
   {
      CloseAllTrades();
   }
   static datetime lastBar;
   datetime currentBar = iTime(_Symbol, PERIOD_CURRENT, 0);
   if(lastBar != currentBar)
   {
      lastBar = currentBar;
      DrawSessionLines();
      DrawHighLowLines();
      DetermineBias();
      DrawBiasCandles(); // DrawBiasDot moved to every tick below
      DebugChartObjects(TimeToString(current_time, TIME_DATE));
   }
   // Detect new daily bar and update EMA line (added)
   static datetime last_daily_bar = 0;
   datetime current_daily_bar = iTime(_Symbol, PERIOD_D1, 0);
   if(current_daily_bar != last_daily_bar)
   {
      last_daily_bar = current_daily_bar;
      DrawDailyEMALine();
   }
   // New: Robust daily reset on D1 change
   if(current_daily_bar != last_daily_time)
   {
      Print("New day detected - full reset");
      last_daily_time = current_daily_bar;
      // Reset all reversal flags and levels
      if(doReversals)
      {
         AsiaLowRaided = false; LondonLowRaided = false; DailyLowRaided = false;
         AsiaHighRaided = false; LondonHighRaided = false; DailyHighRaided = false;
         AsiaLowTrades = 0; LondonLowTrades = 0; DailyLowTrades = 0;
         AsiaHighTrades = 0; LondonHighTrades = 0; DailyHighTrades = 0;
         ActiveLowLevel = DBL_MAX; ActiveLowLevelName = "";
         ActiveHighLevel = DBL_MIN; ActiveHighLevelName = "";
         AsiaLowValidUntil = 0; LondonLowValidUntil = 0; DailyLowValidUntil = 0;
         AsiaHighValidUntil = 0; LondonHighValidUntil = 0; DailyHighValidUntil = 0;
         AsiaLowRaidTime = 0; LondonLowRaidTime = 0; DailyLowRaidTime = 0;
         AsiaHighRaidTime = 0; LondonHighRaidTime = 0; DailyHighRaidTime = 0;
         AsiaLowCurrentRaidTime = 0; LondonLowCurrentRaidTime = 0; DailyLowCurrentRaidTime = 0;
         AsiaHighCurrentRaidTime = 0; LondonHighCurrentRaidTime = 0; DailyHighCurrentRaidTime = 0;
         AsiaLowWaitingForEntry = false; LondonLowWaitingForEntry = false; DailyLowWaitingForEntry = false;
         AsiaHighWaitingForEntry = false; LondonHighWaitingForEntry = false; DailyHighWaitingForEntry = false;
      }
      // Reset all breakout flags and levels
      if(doBreakouts)
      {
         BreakoutAsiaLowRaided = false; BreakoutLondonLowRaided = false; BreakoutDailyLowRaided = false;
         BreakoutAsiaHighRaided = false; BreakoutLondonHighRaided = false; BreakoutDailyHighRaided = false;
         BreakoutAsiaLowTrades = 0; BreakoutLondonLowTrades = 0; BreakoutDailyLowTrades = 0;
         BreakoutAsiaHighTrades = 0; BreakoutLondonHighTrades = 0; BreakoutDailyHighTrades = 0;
         BreakoutActiveLowLevel = DBL_MAX; BreakoutActiveHighLevel = DBL_MIN;
         BreakoutAsiaLowValidUntil = 0; BreakoutLondonLowValidUntil = 0; BreakoutDailyLowValidUntil = 0;
         BreakoutAsiaHighValidUntil = 0; BreakoutLondonHighValidUntil = 0; BreakoutDailyHighValidUntil = 0;
         BreakoutAsiaLowRaidTime = 0; BreakoutLondonLowRaidTime = 0; BreakoutDailyLowRaidTime = 0;
         BreakoutAsiaHighRaidTime = 0; BreakoutLondonHighRaidTime = 0; BreakoutDailyHighRaidTime = 0;
         CurrentBreakoutLowLevelName = ""; CurrentBreakoutLowRaidTime = 0; CurrentBreakoutLowKeyLevel = 0; CurrentBreakoutLowKeyTime = 0;
         BreakoutLowHasKey = false; BreakoutLowWaitingForRetrace = false;
         CurrentBreakoutHighLevelName = ""; CurrentBreakoutHighRaidTime = 0; CurrentBreakoutHighKeyLevel = 0; CurrentBreakoutHighKeyTime = 0;
         BreakoutHighHasKey = false; BreakoutHighWaitingForRetrace = false;
         CurrentBreakoutShortTicket = 0; CurrentBreakoutShortSL = 0;
         CurrentBreakoutLongTicket = 0; CurrentBreakoutLongSL = 0;
         BreakoutRaidedLowInLondon = false; BreakoutRaidedLowInNY = false;
         BreakoutRaidedHighInLondon = false; BreakoutRaidedHighInNY = false;
      }
      ProfitableCloseToday = false; ProfitableCloseLondon = false; ProfitableCloseNY = false;
      LondonLevelsSet = false; LondonLevelsUpdated = false;
      FVGBullishCount = 0; FirstFVGGapLow = 0; LastBullishFVGTime = 0;
      FVGBearishCount = 0; FirstFVGGapHigh = 0; LastBearishFVGTime = 0;
      LatestBullishFVGLower = 0; LatestBullishFVGUpper = 0; LatestBullishFVGSL = 0; LatestBullishLevelName = "";
      HasLeftBullish = false; LatestBearishFVGLower = 0; LatestBearishFVGUpper = 0; LatestBearishFVGSL = 0; LatestBearishLevelName = "";
      HasLeftBearish = false;
      HasTappedFirstBullishFVG = false; TappedFirstBullishGapLow = 0; LatestUntappedBullishGapLow = 0; LatestUntappedBullishGapHigh = 0;
      HasTappedFirstBearishFVG = false; TappedFirstBearishGapHigh = 0; LatestUntappedBearishGapLow = 0; LatestUntappedBearishGapHigh = 0;
      lastDay = current_time - (current_time % 86400);
      LastTradeDay = current_time;
   }
   // Check profitable closes early (moved here for immediate detection)
   if(TradingTimes == EntireDay)
   {
      if(!ProfitableCloseToday) ProfitableCloseToday = CheckProfitableCloseToday();
   }
   else
   {
      if(!ProfitableCloseLondon) ProfitableCloseLondon = CheckProfitableCloseInKillzone("London");
      if(!ProfitableCloseNY) ProfitableCloseNY = CheckProfitableCloseInKillzone("NY");
   }
   // Existing daily reset (enhanced)
   datetime currentDay = current_time - (current_time % 86400);
   if(currentDay > lastDay)
   {
      // Daily reset (added new flags)
      raidedLowInLondon = false;
      raidedLowInNY = false;
      raidedHighInLondon = false;
      raidedHighInNY = false;
      if(doBreakouts)
      {
         BreakoutRaidedLowInLondon = false;
         BreakoutRaidedLowInNY = false;
         BreakoutRaidedHighInLondon = false;
         BreakoutRaidedHighInNY = false;
      }
      ProfitableCloseLondon = false;
      ProfitableCloseNY = false;
      if(doReversals)
      {
         AsiaLowWaitingForEntry = false;
         LondonLowWaitingForEntry = false;
         DailyLowWaitingForEntry = false;
         AsiaHighWaitingForEntry = false;
         LondonHighWaitingForEntry = false;
         DailyHighWaitingForEntry = false;
      }
      lastDay = currentDay;
      lastLondonStart = 0;
      lastNYStart = 0;
      Print("Daily reset: Raided flags cleared.");
   }
   // Reset flag at start of London kill zone
   if (IsInTimeRange(GetLondonKillzoneStart(), GetLondonKillzoneEnd()) && lastLondonStart == 0)
   {
      if (RaidMustBeInKillzone)
      {
         if(doReversals)
         {
            raidedLowInLondon = false;
            raidedHighInLondon = false;
         }
         if(doBreakouts)
         {
            BreakoutRaidedLowInLondon = false;
            BreakoutRaidedHighInLondon = false;
         }
         Print("London kill zone start: Reset raided flags.");
      }
      lastLondonStart = current_time;
   }
   // Reset flag at start of NY kill zone
   if (IsInTimeRange(GetNYKillzoneStart(), GetNYKillzoneEnd()) && lastNYStart == 0)
   {
      if (RaidMustBeInKillzone)
      {
         if(doReversals)
         {
            raidedLowInNY = false;
            raidedHighInNY = false;
         }
         if(doBreakouts)
         {
            BreakoutRaidedLowInNY = false;
            BreakoutRaidedHighInNY = false;
         }
         Print("NY kill zone start: Reset raidedInNY flags.");
      }
      lastNYStart = current_time;
   }
   // New: Update TP after London if applicable (reversals only)
   if(doReversals && LondonLevelsSet && !LondonLevelsUpdated)
   {
      UpdateTPAfterLondon();
   }
   string current_date = TimeToString(current_time, TIME_DATE);
   string prev_date = TimeToString(LastTradeDay, TIME_DATE);
   if(current_date != prev_date)
   {
      DeleteOldBiasObjects(prev_date);
      CloseAllTrades();
      LastTradeDay = current_time;
   }
   datetime time_NYOpen = GetNYOpen();
   if(current_time < time_NYOpen) return;
   string bias = DetermineBias();
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double spread = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double current_low = iLow(_Symbol, PERIOD_CURRENT, 0);
   double current_high = iHigh(_Symbol, PERIOD_CURRENT, 0);
   // Raid detection for lows (reversal)
   if(doReversals)
   {
      // AsiaLow
      if(AsiaLow > 0 && current_low < AsiaLow - tick_size && AsiaLowTrades < maxTradesPerRaidLevel && current_time < AsiaLowValidUntil)
      {
         string level_name = "AsiaLow";
         double level = AsiaLow;
         if(!AsiaLowRaided)
         {
            AsiaLowRaided = true;
            AsiaLowRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            if(!AsiaLowCurrentRaidTime) AsiaLowCurrentRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0); // Set only on first raid
         }
         bool is_duplicate = (ActiveLowLevel != DBL_MAX && MathAbs(ActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = ActiveLowLevelName;
            if(prev_name == "LondonLow") { LondonLowTrades = maxTradesPerRaidLevel; LondonLowValidUntil = current_time; }
            else if(prev_name == "DailyLow") { DailyLowTrades = maxTradesPerRaidLevel; DailyLowValidUntil = current_time; }
            Print("Duplicate low: Maxed active, activating " + level_name);
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         else if(level < ActiveLowLevel)
         {
            if(LondonLow > 0 && LondonLow > level) LondonLowValidUntil = current_time;
            if(DailyLow > 0 && DailyLow > level) DailyLowValidUntil = current_time;
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") raidedLowInLondon = true;
            else if (zone == "NY") raidedLowInNY = true;
         }
      }
      // LondonLow
      if(LondonLow > 0 && current_low < LondonLow - tick_size && LondonLowTrades < maxTradesPerRaidLevel && current_time < LondonLowValidUntil)
      {
         string level_name = "LondonLow";
         double level = LondonLow;
         if(!LondonLowRaided)
         {
            LondonLowRaided = true;
            LondonLowRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            if(!LondonLowCurrentRaidTime) LondonLowCurrentRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0); // Set only on first raid
         }
         bool is_duplicate = (ActiveLowLevel != DBL_MAX && MathAbs(ActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = ActiveLowLevelName;
            if(prev_name == "AsiaLow") { AsiaLowTrades = maxTradesPerRaidLevel; AsiaLowValidUntil = current_time; }
            else if(prev_name == "DailyLow") { DailyLowTrades = maxTradesPerRaidLevel; DailyLowValidUntil = current_time; }
            Print("Duplicate low: Maxed active, activating " + level_name);
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         else if(level < ActiveLowLevel)
         {
            if(AsiaLow > 0 && AsiaLow > level) AsiaLowValidUntil = current_time;
            if(DailyLow > 0 && DailyLow > level) DailyLowValidUntil = current_time;
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") raidedLowInLondon = true;
            else if (zone == "NY") raidedLowInNY = true;
         }
      }
      // DailyLow
      if(DailyLow > 0 && current_low < DailyLow - tick_size && DailyLowTrades < maxTradesPerRaidLevel && current_time < DailyLowValidUntil)
      {
         string level_name = "DailyLow";
         double level = DailyLow;
         if(!DailyLowRaided)
         {
            DailyLowRaided = true;
            DailyLowRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            if(!DailyLowCurrentRaidTime) DailyLowCurrentRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0); // Set only on first raid
         }
         bool is_duplicate = (ActiveLowLevel != DBL_MAX && MathAbs(ActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = ActiveLowLevelName;
            if(prev_name == "AsiaLow") { AsiaLowTrades = maxTradesPerRaidLevel; AsiaLowValidUntil = current_time; }
            else if(prev_name == "LondonLow") { LondonLowTrades = maxTradesPerRaidLevel; LondonLowValidUntil = current_time; }
            Print("Duplicate low: Maxed active, activating " + level_name);
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         else if(level < ActiveLowLevel)
         {
            if(AsiaLow > 0 && AsiaLow > level) AsiaLowValidUntil = current_time;
            if(LondonLow > 0 && LondonLow > level) LondonLowValidUntil = current_time;
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") raidedLowInLondon = true;
            else if (zone == "NY") raidedLowInNY = true;
         }
      }
      // Raid detection for highs (reversal)
      // AsiaHigh
      if(AsiaHigh > 0 && current_high > AsiaHigh + tick_size && AsiaHighTrades < maxTradesPerRaidLevel && current_time < AsiaHighValidUntil)
      {
         string level_name = "AsiaHigh";
         double level = AsiaHigh;
         if(!AsiaHighRaided)
         {
            AsiaHighRaided = true;
            AsiaHighRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            if(!AsiaHighCurrentRaidTime) AsiaHighCurrentRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0); // Set only on first raid
         }
         bool is_duplicate = (ActiveHighLevel != DBL_MIN && MathAbs(ActiveHighLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = ActiveHighLevelName;
            if(prev_name == "LondonHigh") { LondonHighTrades = maxTradesPerRaidLevel; LondonHighValidUntil = current_time; }
            else if(prev_name == "DailyHigh") { DailyHighTrades = maxTradesPerRaidLevel; DailyHighValidUntil = current_time; }
            Print("Duplicate high: Maxed active, activating " + level_name);
            ActiveHighLevel = level;
            ActiveHighLevelName = level_name;
         }
         else if(level > ActiveHighLevel)
         {
            if(LondonHigh > 0 && LondonHigh < level) LondonHighValidUntil = current_time;
            if(DailyHigh > 0 && DailyHigh < level) DailyHighValidUntil = current_time;
            ActiveHighLevel = level;
            ActiveHighLevelName = level_name;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") raidedHighInLondon = true;
            else if (zone == "NY") raidedHighInNY = true;
         }
      }
      // LondonHigh
      if(LondonHigh > 0 && current_high > LondonHigh + tick_size && LondonHighTrades < maxTradesPerRaidLevel && current_time < LondonHighValidUntil)
      {
         string level_name = "LondonHigh";
         double level = LondonHigh;
         if(!LondonHighRaided)
         {
            LondonHighRaided = true;
            LondonHighRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            if(!LondonHighCurrentRaidTime) LondonHighCurrentRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0); // Set only on first raid
         }
         bool is_duplicate = (ActiveHighLevel != DBL_MIN && MathAbs(ActiveHighLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = ActiveHighLevelName;
            if(prev_name == "AsiaHigh") { AsiaHighTrades = maxTradesPerRaidLevel; AsiaHighValidUntil = current_time; }
            else if(prev_name == "DailyHigh") { DailyHighTrades = maxTradesPerRaidLevel; DailyHighValidUntil = current_time; }
            Print("Duplicate high: Maxed active, activating " + level_name);
            ActiveHighLevel = level;
            ActiveHighLevelName = level_name;
         }
         else if(level > ActiveHighLevel)
         {
            if(AsiaHigh > 0 && AsiaHigh < level) AsiaHighValidUntil = current_time;
            if(DailyHigh > 0 && DailyHigh < level) DailyHighValidUntil = current_time;
            ActiveHighLevel = level;
            ActiveHighLevelName = level_name;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") raidedHighInLondon = true;
            else if (zone == "NY") raidedHighInNY = true;
         }
      }
      // DailyHigh
      if(DailyHigh > 0 && current_high > DailyHigh + tick_size && DailyHighTrades < maxTradesPerRaidLevel && current_time < DailyHighValidUntil)
      {
         string level_name = "DailyHigh";
         double level = DailyHigh;
         if(!DailyHighRaided)
         {
            DailyHighRaided = true;
            DailyHighRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            if(!DailyHighCurrentRaidTime) DailyHighCurrentRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0); // Set only on first raid
         }
         bool is_duplicate = (ActiveLowLevel != DBL_MAX && MathAbs(ActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = ActiveLowLevelName;
            if(prev_name == "LondonLow") { LondonLowTrades = maxTradesPerRaidLevel; LondonLowValidUntil = current_time; }
            else if(prev_name == "DailyLow") { DailyLowTrades = maxTradesPerRaidLevel; DailyLowValidUntil = current_time; }
            Print("Duplicate low: Maxed active, activating " + level_name);
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         else
         {
            if(LondonLow > 0 && LondonLow > level) LondonLowValidUntil = current_time;
            if(DailyLow > 0 && DailyLow > level) DailyLowValidUntil = current_time;
            ActiveLowLevel = level;
            ActiveLowLevelName = level_name;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") raidedHighInLondon = true;
            else if (zone == "NY") raidedHighInNY = true;
         }
      }
   }
   // Raid detection for lows (breakout)
   if(doBreakouts)
   {
      // AsiaLow
      if(AsiaLow > 0 && current_low < AsiaLow - tick_size && BreakoutAsiaLowTrades < maxTradesPerRaidLevel && current_time < BreakoutAsiaLowValidUntil)
      {
         string level_name = "AsiaLow";
         double level = AsiaLow;
         if(!BreakoutAsiaLowRaided)
         {
            BreakoutAsiaLowRaided = true;
            BreakoutAsiaLowRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            BreakoutLowWaitingForRetrace = false;
            BreakoutLowHasKey = false;
            CurrentBreakoutLowKeyLevel = 0;
         }
         bool is_duplicate = (BreakoutActiveLowLevel != DBL_MAX && MathAbs(BreakoutActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = CurrentBreakoutLowLevelName;
            if(prev_name == "LondonLow") { BreakoutLondonLowTrades = maxTradesPerRaidLevel; BreakoutLondonLowValidUntil = current_time; }
            else if(prev_name == "DailyLow") { BreakoutDailyLowTrades = maxTradesPerRaidLevel; BreakoutDailyLowValidUntil = current_time; }
            Print("Breakout duplicate low: Maxed active, activating " + level_name);
            BreakoutActiveLowLevel = level;
            CurrentBreakoutLowLevelName = level_name;
         }
         else if(level < BreakoutActiveLowLevel)
         {
            if(LondonLow > 0 && LondonLow > level) BreakoutLondonLowValidUntil = current_time;
            if(DailyLow > 0 && DailyLow > level) BreakoutDailyLowValidUntil = current_time;
            BreakoutActiveLowLevel = level;
            CurrentBreakoutLowLevelName = level_name;
            CurrentBreakoutLowRaidTime = BreakoutAsiaLowRaidTime;
            BreakoutLowWaitingForRetrace = false;
            BreakoutLowHasKey = false;
            CurrentBreakoutLowKeyLevel = 0;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") BreakoutRaidedLowInLondon = true;
            else if (zone == "NY") BreakoutRaidedLowInNY = true;
         }
      }
      // LondonLow
      if(LondonLow > 0 && current_low < LondonLow - tick_size && BreakoutLondonLowTrades < maxTradesPerRaidLevel && current_time < BreakoutLondonLowValidUntil)
      {
         string level_name = "LondonLow";
         double level = LondonLow;
         if(!BreakoutLondonLowRaided)
         {
            BreakoutLondonLowRaided = true;
            BreakoutLondonLowRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            BreakoutLowWaitingForRetrace = false;
            BreakoutLowHasKey = false;
            CurrentBreakoutLowKeyLevel = 0;
         }
         bool is_duplicate = (BreakoutActiveLowLevel != DBL_MAX && MathAbs(BreakoutActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = CurrentBreakoutLowLevelName;
            if(prev_name == "AsiaLow") { BreakoutAsiaLowTrades = maxTradesPerRaidLevel; BreakoutAsiaLowValidUntil = current_time; }
            else if(prev_name == "DailyLow") { BreakoutDailyLowTrades = maxTradesPerRaidLevel; BreakoutDailyLowValidUntil = current_time; }
            Print("Breakout duplicate low: Maxed active, activating " + level_name);
            BreakoutActiveLowLevel = level;
            CurrentBreakoutLowLevelName = level_name;
         }
         else if(level < BreakoutActiveLowLevel)
         {
            if(AsiaLow > 0 && AsiaLow > level) BreakoutAsiaLowValidUntil = current_time;
            if(DailyLow > 0 && DailyLow > level) BreakoutDailyLowValidUntil = current_time;
            BreakoutActiveLowLevel = level;
            CurrentBreakoutLowLevelName = level_name;
            CurrentBreakoutLowRaidTime = BreakoutLondonLowRaidTime;
            BreakoutLowWaitingForRetrace = false;
            BreakoutLowHasKey = false;
            CurrentBreakoutLowKeyLevel = 0;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") BreakoutRaidedLowInLondon = true;
            else if (zone == "NY") BreakoutRaidedLowInNY = true;
         }
      }
      // DailyLow
      if(DailyLow > 0 && current_low < DailyLow - tick_size && BreakoutDailyLowTrades < maxTradesPerRaidLevel && current_time < BreakoutDailyLowValidUntil)
      {
         string level_name = "DailyLow";
         double level = DailyLow;
         if(!BreakoutDailyLowRaided)
         {
            BreakoutDailyLowRaided = true;
            BreakoutDailyLowRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            BreakoutLowWaitingForRetrace = false;
            BreakoutLowHasKey = false;
            CurrentBreakoutLowKeyLevel = 0;
         }
         bool is_duplicate = (BreakoutActiveLowLevel != DBL_MAX && MathAbs(BreakoutActiveLowLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = CurrentBreakoutLowLevelName;
            if(prev_name == "AsiaLow") { BreakoutAsiaLowTrades = maxTradesPerRaidLevel; BreakoutAsiaLowValidUntil = current_time; }
            else if(prev_name == "LondonLow") { BreakoutLondonLowTrades = maxTradesPerRaidLevel; BreakoutLondonLowValidUntil = current_time; }
            Print("Breakout duplicate low: Maxed active, activating " + level_name);
            BreakoutActiveLowLevel = level;
            CurrentBreakoutLowLevelName = level_name;
         }
         else if(level < BreakoutActiveLowLevel)
         {
            if(AsiaLow > 0 && AsiaLow > level) BreakoutAsiaLowValidUntil = current_time;
            if(LondonLow > 0 && LondonLow > level) BreakoutLondonLowValidUntil = current_time;
            BreakoutActiveLowLevel = level;
            CurrentBreakoutLowLevelName = level_name;
            CurrentBreakoutLowRaidTime = BreakoutDailyLowRaidTime;
            BreakoutLowWaitingForRetrace = false;
            BreakoutLowHasKey = false;
            CurrentBreakoutLowKeyLevel = 0;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") BreakoutRaidedLowInLondon = true;
            else if (zone == "NY") BreakoutRaidedLowInNY = true;
         }
      }
      // Raid detection for highs (breakout)
      // AsiaHigh
      if(AsiaHigh > 0 && current_high > AsiaHigh + tick_size && BreakoutAsiaHighTrades < maxTradesPerRaidLevel && current_time < BreakoutAsiaHighValidUntil)
      {
         string level_name = "AsiaHigh";
         double level = AsiaHigh;
         if(!BreakoutAsiaHighRaided)
         {
            BreakoutAsiaHighRaided = true;
            BreakoutAsiaHighRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            BreakoutHighWaitingForRetrace = false;
            BreakoutHighHasKey = false;
            CurrentBreakoutHighKeyLevel = 0;
         }
         bool is_duplicate = (BreakoutActiveHighLevel != DBL_MIN && MathAbs(BreakoutActiveHighLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = CurrentBreakoutHighLevelName;
            if(prev_name == "LondonHigh") { BreakoutLondonHighTrades = maxTradesPerRaidLevel; BreakoutLondonHighValidUntil = current_time; }
            else if(prev_name == "DailyHigh") { BreakoutDailyHighTrades = maxTradesPerRaidLevel; BreakoutDailyHighValidUntil = current_time; }
            Print("Breakout duplicate high: Maxed active, activating " + level_name);
            BreakoutActiveHighLevel = level;
            CurrentBreakoutHighLevelName = level_name;
         }
         else if(level > BreakoutActiveHighLevel)
         {
            if(LondonHigh > 0 && LondonHigh < level) BreakoutLondonHighValidUntil = current_time;
            if(DailyHigh > 0 && DailyHigh < level) BreakoutDailyHighValidUntil = current_time;
            BreakoutActiveHighLevel = level;
            CurrentBreakoutHighLevelName = level_name;
            CurrentBreakoutHighRaidTime = BreakoutAsiaHighRaidTime;
            BreakoutHighWaitingForRetrace = false;
            BreakoutHighHasKey = false;
            CurrentBreakoutHighKeyLevel = 0;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") BreakoutRaidedHighInLondon = true;
            else if (zone == "NY") BreakoutRaidedHighInNY = true;
         }
      }
      // LondonHigh
      if(LondonHigh > 0 && current_high > LondonHigh + tick_size && BreakoutLondonHighTrades < maxTradesPerRaidLevel && current_time < BreakoutLondonHighValidUntil)
      {
         string level_name = "LondonHigh";
         double level = LondonHigh;
         if(!BreakoutLondonHighRaided)
         {
            BreakoutLondonHighRaided = true;
            BreakoutLondonHighRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            BreakoutHighWaitingForRetrace = false;
            BreakoutHighHasKey = false;
            CurrentBreakoutHighKeyLevel = 0;
         }
         bool is_duplicate = (BreakoutActiveHighLevel != DBL_MIN && MathAbs(BreakoutActiveHighLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = CurrentBreakoutHighLevelName;
            if(prev_name == "AsiaHigh") { BreakoutAsiaHighTrades = maxTradesPerRaidLevel; BreakoutAsiaHighValidUntil = current_time; }
            else if(prev_name == "DailyHigh") { BreakoutDailyHighTrades = maxTradesPerRaidLevel; BreakoutDailyHighValidUntil = current_time; }
            Print("Breakout duplicate high: Maxed active, activating " + level_name);
            BreakoutActiveHighLevel = level;
            CurrentBreakoutHighLevelName = level_name;
         }
         else if(level > BreakoutActiveHighLevel)
         {
            if(AsiaHigh > 0 && AsiaHigh < level) BreakoutAsiaHighValidUntil = current_time;
            if(DailyHigh > 0 && DailyHigh < level) BreakoutDailyHighValidUntil = current_time;
            BreakoutActiveHighLevel = level;
            CurrentBreakoutHighLevelName = level_name;
            CurrentBreakoutHighRaidTime = BreakoutLondonHighRaidTime;
            BreakoutHighWaitingForRetrace = false;
            BreakoutHighHasKey = false;
            CurrentBreakoutHighKeyLevel = 0;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") BreakoutRaidedHighInLondon = true;
            else if (zone == "NY") BreakoutRaidedHighInNY = true;
         }
      }
      // DailyHigh
      if(DailyHigh > 0 && current_high > DailyHigh + tick_size && BreakoutDailyHighTrades < maxTradesPerRaidLevel && current_time < BreakoutDailyHighValidUntil)
      {
         string level_name = "DailyHigh";
         double level = DailyHigh;
         if(!BreakoutDailyHighRaided)
         {
            BreakoutDailyHighRaided = true;
            BreakoutDailyHighRaidTime = iTime(_Symbol, PERIOD_CURRENT, 0);
            BreakoutHighWaitingForRetrace = false;
            BreakoutHighHasKey = false;
            CurrentBreakoutHighKeyLevel = 0;
         }
         bool is_duplicate = (BreakoutActiveHighLevel != DBL_MIN && MathAbs(BreakoutActiveHighLevel - level) < 2 * tick_size);
         if(is_duplicate)
         {
            string prev_name = CurrentBreakoutHighLevelName;
            if(prev_name == "AsiaHigh") { BreakoutAsiaHighTrades = maxTradesPerRaidLevel; BreakoutAsiaHighValidUntil = current_time; }
            else if(prev_name == "LondonHigh") { BreakoutLondonHighTrades = maxTradesPerRaidLevel; BreakoutLondonHighValidUntil = current_time; }
            Print("Breakout duplicate high: Maxed active, activating " + level_name);
            BreakoutActiveHighLevel = level;
            CurrentBreakoutHighLevelName = level_name;
         }
         else if(level > BreakoutActiveHighLevel)
         {
            if(AsiaHigh > 0 && AsiaHigh < level) BreakoutAsiaHighValidUntil = current_time;
            if(LondonHigh > 0 && LondonHigh < level) BreakoutLondonHighValidUntil = current_time;
            BreakoutActiveHighLevel = level;
            CurrentBreakoutHighLevelName = level_name;
            CurrentBreakoutHighRaidTime = BreakoutDailyHighRaidTime;
            BreakoutHighWaitingForRetrace = false;
            BreakoutHighHasKey = false;
            CurrentBreakoutHighKeyLevel = 0;
         }
         if (RaidMustBeInKillzone)
         {
            string zone = CurrentKillzone();
            if (zone == "London") BreakoutRaidedHighInLondon = true;
            else if (zone == "NY") BreakoutRaidedHighInNY = true;
         }
      }
   }
   // Determine if we can open new trades based on TradingTimes (modified for per-zone wins)
   bool canOpenTrade = false;
   if (TradingTimes == EntireDay)
   {
      canOpenTrade = IsInTimeRange(GetNYOpen(), GetCloseAll());
      if (ProfitableCloseToday) canOpenTrade = false;
   }
   else if (TradingTimes == OnlyKillzones)
   {
      canOpenTrade = IsInKillzone();
      if (canOpenTrade)
      {
         string zone = CurrentKillzone();
         if (zone == "London" && ProfitableCloseLondon) canOpenTrade = false;
         if (zone == "NY" && ProfitableCloseNY) canOpenTrade = false;
      }
   }
   if(canOpenTrade && AllowEAToTrade)
   {
      static datetime last_checked_bar;
      if(currentBar != last_checked_bar)
      {
         last_checked_bar = currentBar;
         double candle1_low = iLow(_Symbol, PERIOD_CURRENT, 1);
         double candle1_high = iHigh(_Symbol, PERIOD_CURRENT, 1);
         double candle1_close = iClose(_Symbol, PERIOD_CURRENT, 1);
         double candle1_open = iOpen(_Symbol, PERIOD_CURRENT, 1);
         double candle2_low = iLow(_Symbol, PERIOD_CURRENT, 2);
         double candle2_high = iHigh(_Symbol, PERIOD_CURRENT, 2);
         double candle3_low = iLow(_Symbol, PERIOD_CURRENT, 3);
         double candle3_high = iHigh(_Symbol, PERIOD_CURRENT, 3);
         double entry_price_long = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double entry_price_short = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         datetime fvg_time = iTime(_Symbol, PERIOD_CURRENT, 1);
         datetime time1 = iTime(_Symbol, PERIOD_CURRENT, 1);
         // Handle resets and tap detection for twoFVGs (reversal)
         if(doReversals && EntryTypeReversals == twoFVGs)
         {
            // Bullish (longs) invalidation and tap check
            if(HasTappedFirstBullishFVG && TappedFirstBullishGapLow > 0 && candle1_close < TappedFirstBullishGapLow)
            {
               HasTappedFirstBullishFVG = false;
               TappedFirstBullishGapLow = 0;
               LatestUntappedBullishGapLow = 0;
               LatestUntappedBullishGapHigh = 0;
            }
            if(!HasTappedFirstBullishFVG && LatestUntappedBullishGapLow > 0)
            {
               if(candle1_close < LatestUntappedBullishGapLow)
               {
                  LatestUntappedBullishGapLow = 0;
                  LatestUntappedBullishGapHigh = 0;
               }
               else if(candle1_low <= LatestUntappedBullishGapHigh)
               {
                  HasTappedFirstBullishFVG = true;
                  TappedFirstBullishGapLow = LatestUntappedBullishGapLow;
                  LatestUntappedBullishGapLow = 0;
                  LatestUntappedBullishGapHigh = 0;
               }
            }
            // Bearish (shorts) invalidation and tap check
            if(HasTappedFirstBearishFVG && TappedFirstBearishGapHigh > 0 && candle1_close > TappedFirstBearishGapHigh)
            {
               HasTappedFirstBearishFVG = false;
               TappedFirstBearishGapHigh = 0;
               LatestUntappedBearishGapLow = 0;
               LatestUntappedBearishGapHigh = 0;
            }
            if(!HasTappedFirstBearishFVG && LatestUntappedBearishGapHigh > 0)
            {
               if(candle1_close > LatestUntappedBearishGapHigh)
               {
                  LatestUntappedBearishGapLow = 0;
                  LatestUntappedBearishGapHigh = 0;
               }
               else if(candle1_high >= LatestUntappedBearishGapLow)
               {
                  HasTappedFirstBearishFVG = true;
                  TappedFirstBearishGapHigh = LatestUntappedBearishGapHigh;
                  LatestUntappedBearishGapLow = 0;
                  LatestUntappedBearishGapHigh = 0;
               }
            }
         }
         else if(doReversals && EntryTypeReversals == FirstFVGandTap)
         {
            // Original resets for FirstFVGandTap
            if(LatestBullishFVGLower > 0 && candle1_close < LatestBullishFVGLower)
            {
               LatestBullishFVGLower = 0;
               LatestBullishFVGUpper = 0;
               LatestBullishFVGSL = 0;
               LatestBullishLevelName = "";
               HasLeftBullish = false;
            }
            if(LatestBearishFVGUpper > 0 && candle1_close > LatestBearishFVGUpper)
            {
               LatestBearishFVGLower = 0;
               LatestBearishFVGUpper = 0;
               LatestBearishFVGSL = 0;
               LatestBearishLevelName = "";
               HasLeftBearish = false;
            }
         }
         // Reversal entry logic for firstCloseBeyondCandle
         if(doReversals && EntryTypeReversals == firstCloseBeyondCandle)
         {
            MqlRates rates1[1];
            if(CopyRates(_Symbol, PERIOD_CURRENT, 1, 1, rates1) < 1) return;
            double open1 = rates1[0].open;
            double close1 = rates1[0].close;
            double low1 = rates1[0].low;
            double high1 = rates1[0].high;
            // For longs (low levels)
            if(AllowLongTrades && ActiveLowLevel != DBL_MAX && (AsiaLowRaided || LondonLowRaided || DailyLowRaided) && CanOpenNewTrade(true))
            {
               bool bias_ok = (bias == "AllowAll" || bias == "Bullish" || (bias == "Neutral" && TradeOnNeutralDays));
               if(bias_ok)
               {
                  bool raidConditionMetLong = true;
                  if(RaidMustBeInKillzone)
                  {
                     string zone = CurrentKillzone();
                     if(zone == "London") raidConditionMetLong = raidedLowInLondon;
                     else if(zone == "NY") raidConditionMetLong = raidedLowInNY;
                     else raidConditionMetLong = false;
                  }
                  if(raidConditionMetLong)
                  {
                     // Check for AsiaLow if active
                     if(ActiveLowLevelName == "AsiaLow" && AsiaLowRaided && AsiaLowTrades < maxTradesPerRaidLevel && current_time < AsiaLowValidUntil)
                     {
                        string level_name = "AsiaLow";
                        double level = AsiaLow;
                        bool condition_met = (close1 > level) && (close1 > open1);
                        bool new_raid = (low1 < level - tick_size); // Updated: Removed close1 < level
                        bool same_candle_raid = new_raid && condition_met;
                        if((AsiaLowWaitingForEntry && condition_met) || (!AsiaLowWaitingForEntry && same_candle_raid))
                        {
                           if(!AsiaLowWaitingForEntry && same_candle_raid) AsiaLowCurrentRaidTime = time1; // Only set if first raid
                           double entry_price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
                           // Define candles for SL modes
                           MqlRates rates2[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 2, 1, rates2);
                           double candle2_low = rates2[0].low;
                           double candle2_high = rates2[0].high;
                           MqlRates rates3[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 3, 1, rates3);
                           double candle3_low = rates3[0].low;
                           double candle3_high = rates3[0].high;
                           double candle1_low = low1;
                           double candle1_high = high1;
                           double sl_price = 0.0; // Initialize to 0.0
                           datetime raid_time = AsiaLowCurrentRaidTime;
                           if(SLModeReversals == extremeOfRaid)
                           {
                              datetime extreme_time = 0;
                              double extreme_low = GetExtremeOfRaid(true, raid_time, extreme_time);
                              sl_price = NormalizeDouble(extreme_low - tick_size, _Digits);
                              // Mark with magenta dot below the extreme candle's low
                              string dot_name = "SL_Extreme_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                              if(ObjectFind(0, dot_name) < 0)
                              {
                                 double dot_price = extreme_low - 5 * tick_size;
                                 ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                                 ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159); // Wingdings dot
                                 ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrMagenta);
                                 ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                                 ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                              }
                              // Debug print
                              Print("extremeOfRaid (AsiaLow Long): extreme_low=", extreme_low, ", extreme_time=", TimeToString(extreme_time), ", raid_time=", TimeToString(raid_time));
                           }
                           else if(SLModeReversals == SwingPointSL)
                           {
                              double swing = FindSwingLowPoint(time1, entry_price);
                              if(swing == 0 || swing >= entry_price) swing = NormalizeDouble(candle2_low - tick_size, _Digits);
                              double min_low = low1; // Fallback
                              datetime extreme_time_dummy;
                              double extreme_low = GetExtremeOfRaid(true, raid_time, extreme_time_dummy);
                              double extreme_sl = NormalizeDouble(extreme_low - tick_size, _Digits);
                              sl_price = MathMax(swing, extreme_sl);
                           }
                           else if(SLModeReversals == CandleMidSL)
                           {
                              sl_price = NormalizeDouble(candle2_low - tick_size, _Digits);
                           }
                           else if(SLModeReversals == GapBoundarySL)
                           {
                              sl_price = NormalizeDouble(candle3_high - tick_size, _Digits);
                           }
                           else if(SLModeReversals == middleOfVFGSL)
                           {
                              sl_price = NormalizeDouble((candle1_low + candle3_high) / 2 - tick_size, _Digits);
                           }
                           else
                           {
                              // Fallback stop-loss: Use the low of the previous candle minus tick_size
                              Print("Warning: Unhandled SLModeReversals value: ", EnumToString(SLModeReversals), ". Using default stop-loss.");
                              sl_price = NormalizeDouble(candle2_low - tick_size, _Digits);
                           }
                           // Validate sl_price for long trade
                           if(sl_price >= entry_price || sl_price <= 0.0)
                           {
                              Print("Invalid stop-loss price for long trade: sl_price=", sl_price, ", entry_price=", entry_price);
                           }
                           else
                           {
                              double sl_distance = entry_price - sl_price;
                              double tp_price = CalculateTP(true, entry_price, sl_price, sl_distance, level_name); // New dynamic TP!
                              double lot_size = CalculateLotSize(entry_price, sl_price);
                              if(lot_size == 0) {}
                              else
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_BUY;
                                 request.price = entry_price;
                                 request.sl = sl_price;
                                 request.tp = tp_price;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Raid Long (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    AsiaLowTrades++;
                                    int trade_number = AsiaLowTrades;
                                    if(AsiaLowTrades >= maxTradesPerRaidLevel) { AsiaLowValidUntil = current_time; AsiaLowCurrentRaidTime = 0; } // Clear after max
                                    PlotTradeNumber(level_name, trade_number, level, current_time, true);
                                    AsiaLowWaitingForEntry = false;
                                    return; // Exit OnTick to prevent multiple opens
                                 }
                              }
                           }
                        }
                        if(new_raid && !AsiaLowWaitingForEntry)
                        {
                           AsiaLowWaitingForEntry = true;
                           AsiaLowCurrentRaidTime = time1;
                        }
                     }
                     // LondonLow
                     if(ActiveLowLevelName == "LondonLow" && LondonLowRaided && LondonLowTrades < maxTradesPerRaidLevel && current_time < LondonLowValidUntil)
                     {
                        string level_name = "LondonLow";
                        double level = LondonLow;
                        bool condition_met = (close1 > level) && (close1 > open1);
                        bool new_raid = (low1 < level - tick_size);
                        bool same_candle_raid = new_raid && condition_met;
                        if((LondonLowWaitingForEntry && condition_met) || (!LondonLowWaitingForEntry && same_candle_raid))
                        {
                           if(!LondonLowWaitingForEntry && same_candle_raid) LondonLowCurrentRaidTime = time1;
                           double entry_price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
                           MqlRates rates2[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 2, 1, rates2);
                           double candle2_low = rates2[0].low;
                           double candle2_high = rates2[0].high;
                           MqlRates rates3[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 3, 1, rates3);
                           double candle3_low = rates3[0].low;
                           double candle3_high = rates3[0].high;
                           double candle1_low = low1;
                           double candle1_high = high1;
                           double sl_price = 0.0;
                           datetime raid_time = LondonLowCurrentRaidTime;
                           if(SLModeReversals == extremeOfRaid)
                           {
                              datetime extreme_time = 0;
                              double extreme_low = GetExtremeOfRaid(true, raid_time, extreme_time);
                              sl_price = NormalizeDouble(extreme_low - tick_size, _Digits);
                              string dot_name = "SL_Extreme_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                              if(ObjectFind(0, dot_name) < 0)
                              {
                                 double dot_price = extreme_low - 5 * tick_size;
                                 ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                                 ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                                 ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrMagenta);
                                 ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                                 ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                              }
                              Print("extremeOfRaid (LondonLow Long): extreme_low=", extreme_low, ", extreme_time=", TimeToString(extreme_time), ", raid_time=", TimeToString(raid_time));
                           }
                           else if(SLModeReversals == SwingPointSL)
                           {
                              double swing = FindSwingLowPoint(time1, entry_price);
                              if(swing == 0 || swing >= entry_price) swing = NormalizeDouble(candle2_low - tick_size, _Digits);
                              datetime extreme_time_dummy;
                              double extreme_low = GetExtremeOfRaid(true, raid_time, extreme_time_dummy);
                              double extreme_sl = NormalizeDouble(extreme_low - tick_size, _Digits);
                              sl_price = MathMax(swing, extreme_sl);
                           }
                           else if(SLModeReversals == CandleMidSL)
                           {
                              sl_price = NormalizeDouble(candle2_low - tick_size, _Digits);
                           }
                           else if(SLModeReversals == GapBoundarySL)
                           {
                              sl_price = NormalizeDouble(candle3_high - tick_size, _Digits);
                           }
                           else if(SLModeReversals == middleOfVFGSL)
                           {
                              sl_price = NormalizeDouble((candle1_low + candle3_high) / 2 - tick_size, _Digits);
                           }
                           else
                           {
                              Print("Warning: Unhandled SLModeReversals value: ", EnumToString(SLModeReversals), ". Using default stop-loss.");
                              sl_price = NormalizeDouble(candle2_low - tick_size, _Digits);
                           }
                           if(sl_price >= entry_price || sl_price <= 0.0)
                           {
                              Print("Invalid stop-loss price for long trade: sl_price=", sl_price, ", entry_price=", entry_price);
                           }
                           else
                           {
                              double sl_distance = entry_price - sl_price;
                              double tp_price = CalculateTP(true, entry_price, sl_price, sl_distance, level_name);
                              double lot_size = CalculateLotSize(entry_price, sl_price);
                              if(lot_size == 0) {}
                              else
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_BUY;
                                 request.price = entry_price;
                                 request.sl = sl_price;
                                 request.tp = tp_price;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Raid Long (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    LondonLowTrades++;
                                    int trade_number = LondonLowTrades;
                                    if(LondonLowTrades >= maxTradesPerRaidLevel) { LondonLowValidUntil = current_time; LondonLowCurrentRaidTime = 0; }
                                    PlotTradeNumber(level_name, trade_number, level, current_time, true);
                                    LondonLowWaitingForEntry = false;
                                    return;
                                 }
                              }
                           }
                        }
                        if(new_raid && !LondonLowWaitingForEntry)
                        {
                           LondonLowWaitingForEntry = true;
                           LondonLowCurrentRaidTime = time1;
                        }
                     }
                     // DailyLow
                     if(ActiveLowLevelName == "DailyLow" && DailyLowRaided && DailyLowTrades < maxTradesPerRaidLevel && current_time < DailyLowValidUntil)
                     {
                        string level_name = "DailyLow";
                        double level = DailyLow;
                        bool condition_met = (close1 > level) && (close1 > open1);
                        bool new_raid = (low1 < level - tick_size);
                        bool same_candle_raid = new_raid && condition_met;
                        if((DailyLowWaitingForEntry && condition_met) || (!DailyLowWaitingForEntry && same_candle_raid))
                        {
                           if(!DailyLowWaitingForEntry && same_candle_raid) DailyLowCurrentRaidTime = time1;
                           double entry_price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
                           MqlRates rates2[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 2, 1, rates2);
                           double candle2_low = rates2[0].low;
                           double candle2_high = rates2[0].high;
                           MqlRates rates3[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 3, 1, rates3);
                           double candle3_low = rates3[0].low;
                           double candle3_high = rates3[0].high;
                           double candle1_low = low1;
                           double candle1_high = high1;
                           double sl_price = 0.0;
                           datetime raid_time = DailyLowCurrentRaidTime;
                           if(SLModeReversals == extremeOfRaid)
                           {
                              datetime extreme_time = 0;
                              double extreme_low = GetExtremeOfRaid(true, raid_time, extreme_time);
                              sl_price = NormalizeDouble(extreme_low - tick_size, _Digits);
                              string dot_name = "SL_Extreme_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                              if(ObjectFind(0, dot_name) < 0)
                              {
                                 double dot_price = extreme_low - 5 * tick_size;
                                 ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                                 ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                                 ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrMagenta);
                                 ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                                 ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                              }
                              Print("extremeOfRaid (DailyLow Long): extreme_low=", extreme_low, ", extreme_time=", TimeToString(extreme_time), ", raid_time=", TimeToString(raid_time));
                           }
                           else if(SLModeReversals == SwingPointSL)
                           {
                              double swing = FindSwingLowPoint(time1, entry_price);
                              if(swing == 0 || swing >= entry_price) swing = NormalizeDouble(candle2_low - tick_size, _Digits);
                              datetime extreme_time_dummy;
                              double extreme_low = GetExtremeOfRaid(true, raid_time, extreme_time_dummy);
                              double extreme_sl = NormalizeDouble(extreme_low - tick_size, _Digits);
                              sl_price = MathMax(swing, extreme_sl);
                           }
                           else if(SLModeReversals == CandleMidSL)
                           {
                              sl_price = NormalizeDouble(candle2_low - tick_size, _Digits);
                           }
                           else if(SLModeReversals == GapBoundarySL)
                           {
                              sl_price = NormalizeDouble(candle3_high - tick_size, _Digits);
                           }
                           else if(SLModeReversals == middleOfVFGSL)
                           {
                              sl_price = NormalizeDouble((candle1_low + candle3_high) / 2 - tick_size, _Digits);
                           }
                           else
                           {
                              Print("Warning: Unhandled SLModeReversals value: ", EnumToString(SLModeReversals), ". Using default stop-loss.");
                              sl_price = NormalizeDouble(candle2_low - tick_size, _Digits);
                           }
                           if(sl_price >= entry_price || sl_price <= 0.0)
                           {
                              Print("Invalid stop-loss price for long trade: sl_price=", sl_price, ", entry_price=", entry_price);
                           }
                           else
                           {
                              double sl_distance = entry_price - sl_price;
                              double tp_price = CalculateTP(true, entry_price, sl_price, sl_distance, level_name);
                              double lot_size = CalculateLotSize(entry_price, sl_price);
                              if(lot_size == 0) {}
                              else
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_BUY;
                                 request.price = entry_price;
                                 request.sl = sl_price;
                                 request.tp = tp_price;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Raid Long (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    DailyLowTrades++;
                                    int trade_number = DailyLowTrades;
                                    if(DailyLowTrades >= maxTradesPerRaidLevel) { DailyLowValidUntil = current_time; DailyLowCurrentRaidTime = 0; }
                                    PlotTradeNumber(level_name, trade_number, level, current_time, true);
                                    DailyLowWaitingForEntry = false;
                                    return;
                                 }
                              }
                           }
                        }
                        if(new_raid && !DailyLowWaitingForEntry)
                        {
                           DailyLowWaitingForEntry = true;
                           DailyLowCurrentRaidTime = time1;
                        }
                     }
                  }
               }
            }
            // Check if long opened before shorts
            if(HasOpenPosition() && TradeRules == onlyOneTrade) return;
            // For shorts (high levels) - symmetric to longs
            if(AllowShortTrades && ActiveHighLevel != DBL_MIN && (AsiaHighRaided || LondonHighRaided || DailyHighRaided) && CanOpenNewTrade(false))
            {
               bool bias_ok = (bias == "AllowAll" || bias == "Bearish" || (bias == "Neutral" && TradeOnNeutralDays));
               if(bias_ok)
               {
                  bool raidConditionMetShort = true;
                  if(RaidMustBeInKillzone)
                  {
                     string zone = CurrentKillzone();
                     if(zone == "London") raidConditionMetShort = raidedHighInLondon;
                     else if(zone == "NY") raidConditionMetShort = raidedHighInNY;
                     else raidConditionMetShort = false;
                  }
                  if(raidConditionMetShort)
                  {
                     // Check for AsiaHigh if active
                     if(ActiveHighLevelName == "AsiaHigh" && AsiaHighRaided && AsiaHighTrades < maxTradesPerRaidLevel && current_time < AsiaHighValidUntil)
                     {
                        string level_name = "AsiaHigh";
                        double level = AsiaHigh;
                        bool condition_met = (close1 < level) && (close1 < open1);
                        bool new_raid = (high1 > level + tick_size);
                        bool same_candle_raid = new_raid && condition_met;
                        if((AsiaHighWaitingForEntry && condition_met) || (!AsiaHighWaitingForEntry && same_candle_raid))
                        {
                           if(!AsiaHighWaitingForEntry && same_candle_raid) AsiaHighCurrentRaidTime = time1;
                           double entry_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
                           MqlRates rates2[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 2, 1, rates2);
                           double candle2_low = rates2[0].low;
                           double candle2_high = rates2[0].high;
                           MqlRates rates3[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 3, 1, rates3);
                           double candle3_low = rates3[0].low;
                           double candle3_high = rates3[0].high;
                           double candle1_low = low1;
                           double candle1_high = high1;
                           double sl_price = 0.0;
                           datetime raid_time = AsiaHighCurrentRaidTime;
                           if(SLModeReversals == extremeOfRaid)
                           {
                              datetime extreme_time = 0;
                              double extreme_high = GetExtremeOfRaid(false, raid_time, extreme_time);
                              sl_price = NormalizeDouble(extreme_high + tick_size, _Digits);
                              string dot_name = "SL_Extreme_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                              if(ObjectFind(0, dot_name) < 0)
                              {
                                 double dot_price = extreme_high + 5 * tick_size;
                                 ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                                 ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                                 ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrMagenta);
                                 ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                                 ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                              }
                              Print("extremeOfRaid (AsiaHigh Short): extreme_high=", extreme_high, ", extreme_time=", TimeToString(extreme_time), ", raid_time=", TimeToString(raid_time));
                           }
                           else if(SLModeReversals == SwingPointSL)
                           {
                              double swing = FindSwingHighPoint(time1, entry_price);
                              if(swing == 0 || swing <= entry_price) swing = NormalizeDouble(candle2_high + tick_size, _Digits);
                              datetime extreme_time_dummy;
                              double extreme_high = GetExtremeOfRaid(false, raid_time, extreme_time_dummy);
                              double extreme_sl = NormalizeDouble(extreme_high + tick_size, _Digits);
                              sl_price = MathMin(swing, extreme_sl);
                           }
                           else if(SLModeReversals == CandleMidSL)
                           {
                              sl_price = NormalizeDouble(candle2_high + tick_size, _Digits);
                           }
                           else if(SLModeReversals == GapBoundarySL)
                           {
                              sl_price = NormalizeDouble(candle3_low + tick_size, _Digits);
                           }
                           else if(SLModeReversals == middleOfVFGSL)
                           {
                              sl_price = NormalizeDouble((candle1_high + candle3_low) / 2 + tick_size, _Digits);
                           }
                           else
                           {
                              Print("Warning: Unhandled SLModeReversals value: ", EnumToString(SLModeReversals), ". Using default stop-loss.");
                              sl_price = NormalizeDouble(candle2_high + tick_size, _Digits);
                           }
                           if(sl_price <= entry_price || sl_price <= 0.0)
                           {
                              Print("Invalid stop-loss price for short trade: sl_price=", sl_price, ", entry_price=", entry_price);
                           }
                           else
                           {
                              double sl_distance = sl_price - entry_price;
                              double tp_price = CalculateTP(false, entry_price, sl_price, sl_distance, level_name);
                              double lot_size = CalculateLotSize(entry_price, sl_price);
                              if(lot_size == 0) {}
                              else
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_SELL;
                                 request.price = entry_price;
                                 request.sl = sl_price;
                                 request.tp = tp_price;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Raid Short (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    AsiaHighTrades++;
                                    int trade_number = AsiaHighTrades;
                                    if(AsiaHighTrades >= maxTradesPerRaidLevel) { AsiaHighValidUntil = current_time; AsiaHighCurrentRaidTime = 0; }
                                    PlotTradeNumber(level_name, trade_number, level, current_time, false);
                                    AsiaHighWaitingForEntry = false;
                                    return;
                                 }
                              }
                           }
                        }
                        if(new_raid && !AsiaHighWaitingForEntry)
                        {
                           AsiaHighWaitingForEntry = true;
                           AsiaHighCurrentRaidTime = time1;
                        }
                     }
                     // LondonHigh
                     if(ActiveHighLevelName == "LondonHigh" && LondonHighRaided && LondonHighTrades < maxTradesPerRaidLevel && current_time < LondonHighValidUntil)
                     {
                        string level_name = "LondonHigh";
                        double level = LondonHigh;
                        bool condition_met = (close1 < level) && (close1 < open1);
                        bool new_raid = (high1 > level + tick_size);
                        bool same_candle_raid = new_raid && condition_met;
                        if((LondonHighWaitingForEntry && condition_met) || (!LondonHighWaitingForEntry && same_candle_raid))
                        {
                           if(!LondonHighWaitingForEntry && same_candle_raid) LondonHighCurrentRaidTime = time1;
                           double entry_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
                           MqlRates rates2[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 2, 1, rates2);
                           double candle2_low = rates2[0].low;
                           double candle2_high = rates2[0].high;
                           MqlRates rates3[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 3, 1, rates3);
                           double candle3_low = rates3[0].low;
                           double candle3_high = rates3[0].high;
                           double candle1_low = low1;
                           double candle1_high = high1;
                           double sl_price = 0.0;
                           datetime raid_time = LondonHighCurrentRaidTime;
                           if(SLModeReversals == extremeOfRaid)
                           {
                              datetime extreme_time = 0;
                              double extreme_high = GetExtremeOfRaid(false, raid_time, extreme_time);
                              sl_price = NormalizeDouble(extreme_high + tick_size, _Digits);
                              string dot_name = "SL_Extreme_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                              if(ObjectFind(0, dot_name) < 0)
                              {
                                 double dot_price = extreme_high + 5 * tick_size;
                                 ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                                 ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                                 ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrMagenta);
                                 ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                                 ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                              }
                              Print("extremeOfRaid (LondonHigh Short): extreme_high=", extreme_high, ", extreme_time=", TimeToString(extreme_time), ", raid_time=", TimeToString(raid_time));
                           }
                           else if(SLModeReversals == SwingPointSL)
                           {
                              double swing = FindSwingHighPoint(time1, entry_price);
                              if(swing == 0 || swing <= entry_price) swing = NormalizeDouble(candle2_high + tick_size, _Digits);
                              datetime extreme_time_dummy;
                              double extreme_high = GetExtremeOfRaid(false, raid_time, extreme_time_dummy);
                              double extreme_sl = NormalizeDouble(extreme_high + tick_size, _Digits);
                              sl_price = MathMin(swing, extreme_sl);
                           }
                           else if(SLModeReversals == CandleMidSL)
                           {
                              sl_price = NormalizeDouble(candle2_high + tick_size, _Digits);
                           }
                           else if(SLModeReversals == GapBoundarySL)
                           {
                              sl_price = NormalizeDouble(candle3_low + tick_size, _Digits);
                           }
                           else if(SLModeReversals == middleOfVFGSL)
                           {
                              sl_price = NormalizeDouble((candle1_high + candle3_low) / 2 + tick_size, _Digits);
                           }
                           else
                           {
                              Print("Warning: Unhandled SLModeReversals value: ", EnumToString(SLModeReversals), ". Using default stop-loss.");
                              sl_price = NormalizeDouble(candle2_high + tick_size, _Digits);
                           }
                           if(sl_price <= entry_price || sl_price <= 0.0)
                           {
                              Print("Invalid stop-loss price for short trade: sl_price=", sl_price, ", entry_price=", entry_price);
                           }
                           else
                           {
                              double sl_distance = sl_price - entry_price;
                              double tp_price = CalculateTP(false, entry_price, sl_price, sl_distance, level_name);
                              double lot_size = CalculateLotSize(entry_price, sl_price);
                              if(lot_size == 0) {}
                              else
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_SELL;
                                 request.price = entry_price;
                                 request.sl = sl_price;
                                 request.tp = tp_price;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Raid Short (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    LondonHighTrades++;
                                    int trade_number = LondonHighTrades;
                                    if(LondonHighTrades >= maxTradesPerRaidLevel) { LondonHighValidUntil = current_time; LondonHighCurrentRaidTime = 0; }
                                    PlotTradeNumber(level_name, trade_number, level, current_time, false);
                                    LondonHighWaitingForEntry = false;
                                    return;
                                 }
                              }
                           }
                        }
                        if(new_raid && !LondonHighWaitingForEntry)
                        {
                           LondonHighWaitingForEntry = true;
                           LondonHighCurrentRaidTime = time1;
                        }
                     }
                     // DailyHigh
                     if(ActiveHighLevelName == "DailyHigh" && DailyHighRaided && DailyHighTrades < maxTradesPerRaidLevel && current_time < DailyHighValidUntil)
                     {
                        string level_name = "DailyHigh";
                        double level = DailyHigh;
                        bool condition_met = (close1 < level) && (close1 < open1);
                        bool new_raid = (high1 > level + tick_size);
                        bool same_candle_raid = new_raid && condition_met;
                        if((DailyHighWaitingForEntry && condition_met) || (!DailyHighWaitingForEntry && same_candle_raid))
                        {
                           if(!DailyHighWaitingForEntry && same_candle_raid) DailyHighCurrentRaidTime = time1;
                           double entry_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
                           MqlRates rates2[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 2, 1, rates2);
                           double candle2_low = rates2[0].low;
                           double candle2_high = rates2[0].high;
                           MqlRates rates3[1];
                           CopyRates(_Symbol, PERIOD_CURRENT, 3, 1, rates3);
                           double candle3_low = rates3[0].low;
                           double candle3_high = rates3[0].high;
                           double candle1_low = low1;
                           double candle1_high = high1;
                           double sl_price = 0.0;
                           datetime raid_time = DailyHighCurrentRaidTime;
                           if(SLModeReversals == extremeOfRaid)
                           {
                              datetime extreme_time = 0;
                              double extreme_high = GetExtremeOfRaid(false, raid_time, extreme_time);
                              sl_price = NormalizeDouble(extreme_high + tick_size, _Digits);
                              string dot_name = "SL_Extreme_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                              if(ObjectFind(0, dot_name) < 0)
                              {
                                 double dot_price = extreme_high + 5 * tick_size;
                                 ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                                 ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                                 ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrMagenta);
                                 ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                                 ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                                 ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                              }
                              Print("extremeOfRaid (DailyHigh Short): extreme_high=", extreme_high, ", extreme_time=", TimeToString(extreme_time), ", raid_time=", TimeToString(raid_time));
                           }
                           else if(SLModeReversals == SwingPointSL)
                           {
                              double swing = FindSwingHighPoint(time1, entry_price);
                              if(swing == 0 || swing <= entry_price) swing = NormalizeDouble(candle2_high + tick_size, _Digits);
                              datetime extreme_time_dummy;
                              double extreme_high = GetExtremeOfRaid(false, raid_time, extreme_time_dummy);
                              double extreme_sl = NormalizeDouble(extreme_high + tick_size, _Digits);
                              sl_price = MathMin(swing, extreme_sl);
                           }
                           else if(SLModeReversals == CandleMidSL)
                           {
                              sl_price = NormalizeDouble(candle2_high + tick_size, _Digits);
                           }
                           else if(SLModeReversals == GapBoundarySL)
                           {
                              sl_price = NormalizeDouble(candle3_low + tick_size, _Digits);
                           }
                           else if(SLModeReversals == middleOfVFGSL)
                           {
                              sl_price = NormalizeDouble((candle1_high + candle3_low) / 2 + tick_size, _Digits);
                           }
                           else
                           {
                              Print("Warning: Unhandled SLModeReversals value: ", EnumToString(SLModeReversals), ". Using default stop-loss.");
                              sl_price = NormalizeDouble(candle2_high + tick_size, _Digits);
                           }
                           if(sl_price <= entry_price || sl_price <= 0.0)
                           {
                              Print("Invalid stop-loss price for short trade: sl_price=", sl_price, ", entry_price=", entry_price);
                           }
                           else
                           {
                              double sl_distance = sl_price - entry_price;
                              double tp_price = CalculateTP(false, entry_price, sl_price, sl_distance, level_name);
                              double lot_size = CalculateLotSize(entry_price, sl_price);
                              if(lot_size == 0) {}
                              else
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_SELL;
                                 request.price = entry_price;
                                 request.sl = sl_price;
                                 request.tp = tp_price;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Raid Short (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    DailyHighTrades++;
                                    int trade_number = DailyHighTrades;
                                    if(DailyHighTrades >= maxTradesPerRaidLevel) { DailyHighValidUntil = current_time; DailyHighCurrentRaidTime = 0; }
                                    PlotTradeNumber(level_name, trade_number, level, current_time, false);
                                    DailyHighWaitingForEntry = false;
                                    return;
                                 }
                              }
                           }
                        }
                        if(new_raid && !DailyHighWaitingForEntry)
                        {
                           DailyHighWaitingForEntry = true;
                           DailyHighCurrentRaidTime = time1;
                        }
                     }
                  }
               }
            }
         }
         // FVG detection and entry for twoFVGs and FirstFVGandTap (reversal)
         if(doReversals && (EntryTypeReversals == twoFVGs || EntryTypeReversals == FirstFVGandTap))
         {
            // Add your FVG detection and entry logic here (e.g., detect gaps between candle3 high/low and candle1, count/tap, then open trade).
            // Example placeholder:
            // if(FVGBullishCount == 2 && HasTappedFirstBullishFVG && !HasOpenPosition()) { // open long }
            // Ensure SL/TP/lot size calculation similar to above.
         }
         // Breakout entry logic (moved inside new-bar check for consistency)
         if(doBreakouts)
         {
            // Get candles for breakout
            double close1 = iClose(_Symbol, PERIOD_CURRENT, 1);
            double open1 = iOpen(_Symbol, PERIOD_CURRENT, 1);
            double low1 = iLow(_Symbol, PERIOD_CURRENT, 1);
            double high1 = iHigh(_Symbol, PERIOD_CURRENT, 1);
            datetime time1 = iTime(_Symbol, PERIOD_CURRENT, 1);
            double candle2_low = iLow(_Symbol, PERIOD_CURRENT, 2);
            double candle2_high = iHigh(_Symbol, PERIOD_CURRENT, 2);
            // Breakout short (low setup)
            if(AllowShortTrades && BreakoutActiveLowLevel != DBL_MAX && CanOpenNewBreakoutTrade(false))
            {
               bool bias_ok = (bias == "AllowAll" || bias == "Bearish" || (bias == "Neutral" && TradeOnNeutralDays));
               if(bias_ok)
               {
                  bool raidConditionMetShort = true;
                  if(RaidMustBeInKillzone)
                  {
                     string zone = CurrentKillzone();
                     if(zone == "London") raidConditionMetShort = BreakoutRaidedLowInLondon;
                     else if(zone == "NY") raidConditionMetShort = BreakoutRaidedLowInNY;
                     else raidConditionMetShort = false;
                  }
                  if(raidConditionMetShort)
                  {
                     string level_name = CurrentBreakoutLowLevelName;
                     double level = BreakoutActiveLowLevel;
                     int trades = 0;
                     datetime valid_until = 0;
                     if(level_name == "AsiaLow") { trades = BreakoutAsiaLowTrades; valid_until = BreakoutAsiaLowValidUntil; }
                     else if(level_name == "LondonLow") { trades = BreakoutLondonLowTrades; valid_until = BreakoutLondonLowValidUntil; }
                     else if(level_name == "DailyLow") { trades = BreakoutDailyLowTrades; valid_until = BreakoutDailyLowValidUntil; }
                     if(trades < maxTradesPerRaidLevel && current_time < valid_until)
                     {
                        if(!BreakoutLowWaitingForRetrace && close1 > level)
                        {
                           // Trigger retrace, calculate key low
                           datetime extreme_time = 0;
                           double key_low = GetExtremeOfRaid(true, CurrentBreakoutLowRaidTime, extreme_time);
                           CurrentBreakoutLowKeyLevel = key_low;
                           CurrentBreakoutLowKeyTime = extreme_time;
                           CurrentBreakoutLowKeySetTime = time1; // New: Capture set time to prevent same-bar entry
                           BreakoutLowHasKey = true;
                           BreakoutLowWaitingForRetrace = true;
                           // Draw gray dot below key low
                           string dot_name = "BreakoutKeyLow_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                           if(ObjectFind(0, dot_name) < 0)
                           {
                              double dot_price = key_low - 5 * tick_size;
                              ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                              ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                              ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrGray);
                              ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                              ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                              ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                              ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                           }
                           Print("Breakout low key set: ", key_low, " at ", TimeToString(extreme_time));
                        }
                        if(BreakoutLowHasKey && close1 < CurrentBreakoutLowKeyLevel && time1 > CurrentBreakoutLowKeySetTime)
                        {
                           // Enter short
                           double entry = SymbolInfoDouble(_Symbol, SYMBOL_BID);
                           double sl = FindSwingHighPoint(time1, entry);
                           if(sl == 0 || sl <= entry) sl = candle2_high + tick_size;
                           double sl_dist = sl - entry;
                           if(sl_dist > 0)
                           {
                              double tp = entry - BreakoutTPMultiple * sl_dist;
                              double lot_size = CalculateLotSize(entry, sl);
                              if(lot_size > 0)
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_SELL;
                                 request.price = entry;
                                 request.sl = sl;
                                 request.tp = tp;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Breakout Short (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    // Find position ticket
                                    ulong pos_ticket = 0;
                                    for(int k = 0; k < PositionsTotal(); k++)
                                    {
                                       ulong tt = PositionGetTicket(k);
                                       if(PositionSelectByTicket(tt) && PositionGetString(POSITION_SYMBOL) == _Symbol && StringFind(PositionGetString(POSITION_COMMENT), "Breakout Short") >= 0)
                                       {
                                          pos_ticket = tt;
                                          break;
                                       }
                                    }
                                    if(pos_ticket > 0)
                                    {
                                       CurrentBreakoutShortTicket = pos_ticket;
                                       CurrentBreakoutShortSL = sl;
                                    }
                                    // Increment trades
                                    if(level_name == "AsiaLow") BreakoutAsiaLowTrades++;
                                    else if(level_name == "LondonLow") BreakoutLondonLowTrades++;
                                    else if(level_name == "DailyLow") BreakoutDailyLowTrades++;
                                    int trade_number = trades + 1;
                                    PlotTradeNumber(level_name, trade_number, level, current_time, false, true); // New: Pass isBreakout=true
                                    if(trades + 1 >= maxTradesPerRaidLevel)
                                    {
                                       if(level_name == "AsiaLow") BreakoutAsiaLowValidUntil = current_time;
                                       else if(level_name == "LondonLow") BreakoutLondonLowValidUntil = current_time;
                                       else if(level_name == "DailyLow") BreakoutDailyLowValidUntil = current_time;
                                       BreakoutLowHasKey = false;
                                       CurrentBreakoutLowKeyLevel = 0;
                                       BreakoutLowWaitingForRetrace = false;
                                       CurrentBreakoutLowKeySetTime = 0; // New: Reset timestamp
                                    }
                                    return; // Prevent multiple
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
            // Breakout long (high setup) - symmetric to short
            if(AllowLongTrades && BreakoutActiveHighLevel != DBL_MIN && CanOpenNewBreakoutTrade(true))
            {
               bool bias_ok = (bias == "AllowAll" || bias == "Bullish" || (bias == "Neutral" && TradeOnNeutralDays));
               if(bias_ok)
               {
                  bool raidConditionMetLong = true;
                  if(RaidMustBeInKillzone)
                  {
                     string zone = CurrentKillzone();
                     if(zone == "London") raidConditionMetLong = BreakoutRaidedHighInLondon;
                     else if(zone == "NY") raidConditionMetLong = BreakoutRaidedHighInNY;
                     else raidConditionMetLong = false;
                  }
                  if(raidConditionMetLong)
                  {
                     string level_name = CurrentBreakoutHighLevelName;
                     double level = BreakoutActiveHighLevel;
                     int trades = 0;
                     datetime valid_until = 0;
                     if(level_name == "AsiaHigh") { trades = BreakoutAsiaHighTrades; valid_until = BreakoutAsiaHighValidUntil; }
                     else if(level_name == "LondonHigh") { trades = BreakoutLondonHighTrades; valid_until = BreakoutLondonHighValidUntil; }
                     else if(level_name == "DailyHigh") { trades = BreakoutDailyHighTrades; valid_until = BreakoutDailyHighValidUntil; }
                     if(trades < maxTradesPerRaidLevel && current_time < valid_until)
                     {
                        if(!BreakoutHighWaitingForRetrace && close1 < level)
                        {
                           // Trigger retrace, calculate key high
                           datetime extreme_time = 0;
                           double key_high = GetExtremeOfRaid(false, CurrentBreakoutHighRaidTime, extreme_time);
                           CurrentBreakoutHighKeyLevel = key_high;
                           CurrentBreakoutHighKeyTime = extreme_time;
                           CurrentBreakoutHighKeySetTime = time1; // New: Capture set time to prevent same-bar entry
                           BreakoutHighHasKey = true;
                           BreakoutHighWaitingForRetrace = true;
                           // Draw gray dot above key high
                           string dot_name = "BreakoutKeyHigh_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                           if(ObjectFind(0, dot_name) < 0)
                           {
                              double dot_price = key_high + 5 * tick_size;
                              ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                              ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                              ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrGray);
                              ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                              ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                              ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                              ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                           }
                           Print("Breakout high key set: ", key_high, " at ", TimeToString(extreme_time));
                        }
                        if(BreakoutHighHasKey && close1 > CurrentBreakoutHighKeyLevel && time1 > CurrentBreakoutHighKeySetTime)
                        {
                           // Enter long
                           double entry = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
                           double sl = FindSwingLowPoint(time1, entry);
                           if(sl == 0 || sl >= entry) sl = candle2_low - tick_size;
                           double sl_dist = entry - sl;
                           if(sl_dist > 0)
                           {
                              double tp = entry + BreakoutTPMultiple * sl_dist;
                              double lot_size = CalculateLotSize(entry, sl);
                              if(lot_size > 0)
                              {
                                 MqlTradeRequest request;
                                 MqlTradeResult result;
                                 ZeroMemory(request);
                                 ZeroMemory(result);
                                 request.action = TRADE_ACTION_DEAL;
                                 request.symbol = _Symbol;
                                 request.volume = lot_size;
                                 request.type = ORDER_TYPE_BUY;
                                 request.price = entry;
                                 request.sl = sl;
                                 request.tp = tp;
                                 request.type_filling = ORDER_FILLING_IOC;
                                 request.comment = "Breakout Long (" + level_name + ")";
                                 bool success = OrderSend(request, result);
                                 if(success && result.retcode == TRADE_RETCODE_DONE)
                                 {
                                    // Find position ticket
                                    ulong pos_ticket = 0;
                                    for(int k = 0; k < PositionsTotal(); k++)
                                    {
                                       ulong tt = PositionGetTicket(k);
                                       if(PositionSelectByTicket(tt) && PositionGetString(POSITION_SYMBOL) == _Symbol && StringFind(PositionGetString(POSITION_COMMENT), "Breakout Long") >= 0)
                                       {
                                          pos_ticket = tt;
                                          break;
                                       }
                                    }
                                    if(pos_ticket > 0)
                                    {
                                       CurrentBreakoutLongTicket = pos_ticket;
                                       CurrentBreakoutLongSL = sl;
                                    }
                                    // Increment trades
                                    if(level_name == "AsiaHigh") BreakoutAsiaHighTrades++;
                                    else if(level_name == "LondonHigh") BreakoutLondonHighTrades++;
                                    else if(level_name == "DailyHigh") BreakoutDailyHighTrades++;
                                    int trade_number = trades + 1;
                                    PlotTradeNumber(level_name, trade_number, level, current_time, true, true); // New: Pass isBreakout=true
                                    if(trades + 1 >= maxTradesPerRaidLevel)
                                    {
                                       if(level_name == "AsiaHigh") BreakoutAsiaHighValidUntil = current_time;
                                       else if(level_name == "LondonHigh") BreakoutLondonHighValidUntil = current_time;
                                       else if(level_name == "DailyHigh") BreakoutDailyHighValidUntil = current_time;
                                       BreakoutHighHasKey = false;
                                       CurrentBreakoutHighKeyLevel = 0;
                                       BreakoutHighWaitingForRetrace = false;
                                       CurrentBreakoutHighKeySetTime = 0; // New: Reset timestamp
                                    }
                                    return; // Prevent multiple
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   // Draw bias dot every tick for dynamic positioning (added)
   DrawBiasDot(TimeToString(current_time, TIME_DATE));
   if(UseBE)
   {
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket) && PositionGetString(POSITION_SYMBOL) == _Symbol)
         {
            long pos_type = PositionGetInteger(POSITION_TYPE);
            double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
            double sl_price = PositionGetDouble(POSITION_SL);
            double current_price = (pos_type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
            double R = MathAbs(entry_price - sl_price);
            double be_trigger = (pos_type == POSITION_TYPE_BUY) ? entry_price + NumberOfRForBE * R : entry_price - NumberOfRForBE * R;
            bool should_move_be = false;
            if(pos_type == POSITION_TYPE_BUY)
            {
               if(current_price >= be_trigger && sl_price < entry_price)
                  should_move_be = true;
            }
            else
            {
               if(current_price <= be_trigger && sl_price > entry_price)
                  should_move_be = true;
            }
            if(should_move_be)
            {
               double tp_price = PositionGetDouble(POSITION_TP);
               MqlTradeRequest request;
               MqlTradeResult result;
               ZeroMemory(request);
               ZeroMemory(result);
               request.action = TRADE_ACTION_SLTP;
               request.position = ticket;
               request.symbol = _Symbol;
               request.sl = entry_price;
               request.tp = tp_price;
               bool success = OrderSend(request, result);
               if(success)
               {
                  Print("BE updated for ticket ", ticket);
               }
            }
         }
      }
   }
   // Check for breakout SL hit (short)
   if(doBreakouts && CurrentBreakoutShortTicket != 0 && !PositionSelectByTicket(CurrentBreakoutShortTicket))
   {
      if(HistorySelectByPosition(CurrentBreakoutShortTicket))
      {
         int total_deals = HistoryDealsTotal();
         if(total_deals > 1)
         {
            ulong exit_deal = HistoryDealGetTicket(total_deals - 1);
            if(HistoryDealGetInteger(exit_deal, DEAL_ENTRY) == DEAL_ENTRY_OUT)
            {
               double profit = HistoryDealGetDouble(exit_deal, DEAL_PROFIT);
               double profit_threshold = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercentage / 100.0 / 4.0;
               string level_name = CurrentBreakoutLowLevelName;
               int trades = 0;
               if(level_name == "AsiaLow") trades = BreakoutAsiaLowTrades;
               else if(level_name == "LondonLow") trades = BreakoutLondonLowTrades;
               else if(level_name == "DailyLow") trades = BreakoutDailyLowTrades;
               if(profit <= profit_threshold && trades < maxTradesPerRaidLevel)
               {
                  // Non-winning close, update key low
                  datetime extreme_time = 0;
                  double new_key = GetExtremeOfRaid(true, CurrentBreakoutLowRaidTime, extreme_time);
                  if(new_key < CurrentBreakoutLowKeyLevel)
                  {
                     CurrentBreakoutLowKeyLevel = new_key;
                     CurrentBreakoutLowKeyTime = extreme_time;
                     // Draw updated gray dot
                     string dot_name = "BreakoutKeyLow_Update_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                     double dot_price = new_key - 5 * tick_size;
                     ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                     ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                     ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrGray);
                     ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                     ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                     ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                     ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                     Print("Breakout short non-winning close, updated key low: ", new_key);
                  }
               }
            }
         }
      }
      CurrentBreakoutShortTicket = 0;
      CurrentBreakoutShortSL = 0;
   }
   // Check for breakout SL hit (long) - symmetric
   if(doBreakouts && CurrentBreakoutLongTicket != 0 && !PositionSelectByTicket(CurrentBreakoutLongTicket))
   {
      if(HistorySelectByPosition(CurrentBreakoutLongTicket))
      {
         int total_deals = HistoryDealsTotal();
         if(total_deals > 1)
         {
            ulong exit_deal = HistoryDealGetTicket(total_deals - 1);
            if(HistoryDealGetInteger(exit_deal, DEAL_ENTRY) == DEAL_ENTRY_OUT)
            {
               double profit = HistoryDealGetDouble(exit_deal, DEAL_PROFIT);
               double profit_threshold = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercentage / 100.0 / 4.0;
               string level_name = CurrentBreakoutHighLevelName;
               int trades = 0;
               if(level_name == "AsiaHigh") trades = BreakoutAsiaHighTrades;
               else if(level_name == "LondonHigh") trades = BreakoutLondonHighTrades;
               else if(level_name == "DailyHigh") trades = BreakoutDailyHighTrades;
               if(profit <= profit_threshold && trades < maxTradesPerRaidLevel)
               {
                  // Non-winning close, update key high
                  datetime extreme_time = 0;
                  double new_key = GetExtremeOfRaid(false, CurrentBreakoutHighRaidTime, extreme_time);
                  if(new_key > CurrentBreakoutHighKeyLevel)
                  {
                     CurrentBreakoutHighKeyLevel = new_key;
                     CurrentBreakoutHighKeyTime = extreme_time;
                     // Draw updated gray dot
                     string dot_name = "BreakoutKeyHigh_Update_" + TimeToString(extreme_time, TIME_DATE|TIME_MINUTES);
                     double dot_price = new_key + 5 * tick_size;
                     ObjectCreate(0, dot_name, OBJ_ARROW, 0, extreme_time, dot_price);
                     ObjectSetInteger(0, dot_name, OBJPROP_ARROWCODE, 159);
                     ObjectSetInteger(0, dot_name, OBJPROP_COLOR, clrGray);
                     ObjectSetInteger(0, dot_name, OBJPROP_WIDTH, 2);
                     ObjectSetInteger(0, dot_name, OBJPROP_BACK, false);
                     ObjectSetInteger(0, dot_name, OBJPROP_SELECTABLE, false);
                     ObjectSetInteger(0, dot_name, OBJPROP_TIMEFRAMES, OBJ_PERIOD_M1|OBJ_PERIOD_M5|OBJ_PERIOD_M15|OBJ_PERIOD_H1|OBJ_PERIOD_H4);
                     Print("Breakout long non-winning close, updated key high: ", new_key);
                  }
               }
            }
         }
      }
      CurrentBreakoutLongTicket = 0;
      CurrentBreakoutLongSL = 0;
   }
}
//+------------------------------------------------------------------+
